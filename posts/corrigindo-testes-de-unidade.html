<!DOCTYPE html><html lang="pt"><head><meta charSet="utf-8"/><meta name="description" content="Blog Yudi Yamane"/><link rel="icon" href="/blog/favicon.ico"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title> Corrigindo testes de unidade </title><meta name="description" content="Um aspecto importante para escrever um bom teste de
unidade é ter em mente qual é a unidade sob teste
"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/github-dark.min.css"/><meta name="next-head-count" content="5"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/blog/_next/static/chunks/webpack-d5cba7b40139ad0e.js" defer=""></script><script src="/blog/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/blog/_next/static/chunks/main-c49c0467e5b05e2b.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-20a8eca4c4863d93.js" defer=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-d4640a255ac65d8b.js" defer=""></script><script src="/blog/_next/static/7BjNWWaJAhJp2ApepI5-W/_buildManifest.js" defer=""></script><script src="/blog/_next/static/7BjNWWaJAhJp2ApepI5-W/_ssgManifest.js" defer=""></script><script src="/blog/_next/static/7BjNWWaJAhJp2ApepI5-W/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.3">:root{font-size:16px;--color-background:#1a1a1a;--color-background-complementary:#2e2e2e;--color-highlight:#fff;--color-primary:rgba(255,255,255,.84);--color-primary:rgba(255,255,255,1);--color-secondary:rgba(255,255,255,.6);--color-muted:rgba(255,255,255,.5);--color-muted-highlight:rgba(255,255,255,.7);--color-code-background:#0e0e0e;--color-code-background-complementary:#2e2e2e;}/*!sc*/
*{margin:0;padding:0;box-sizing:border-box;outline:0;}/*!sc*/
html{overflow-y:overlay;}/*!sc*/
body{line-height:1.5;background:var(--color-background);color:var(--color-primary);-webkit-font-smoothing:antialiased;}/*!sc*/
body::-webkit-scrollbar{width:12px;margin-right:4px;}/*!sc*/
body::-webkit-scrollbar-track{background:transparent;}/*!sc*/
body::-webkit-scrollbar-thumb{background:var(--color-code-background-complementary);border-radius:10px;}/*!sc*/
body,input,button{font-family:Roboto,sans-serif;font-size:16px;}/*!sc*/
h1,h2,h3,h4,h5,h6,strong{font-weight:bold;color:var(--color-highlight);}/*!sc*/
h1{font-size:2.25rem;}/*!sc*/
h2{font-size:1.5rem;}/*!sc*/
h3{font-size:1rem;}/*!sc*/
button{cursor:pointer;}/*!sc*/
a{color:var(--color-secondary);-webkit-text-decoration:underline;text-decoration:underline;-webkit-transition:0.2s;transition:0.2s;}/*!sc*/
a:hover{-webkit-text-decoration:underline;text-decoration:underline;color:var(--color-highlight);}/*!sc*/
ul,li{list-style:none;}/*!sc*/
data-styled.g1[id="sc-global-lkRZuY1"]{content:"sc-global-lkRZuY1,"}/*!sc*/
.cfTPtW{background:transparent;color:var(--color-primary);height:90px;width:100vw;}/*!sc*/
data-styled.g2[id="sc-bdvvtL"]{content:"cfTPtW,"}/*!sc*/
.cyxuZC{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;font-size:1.25rem;width:90%;height:100%;margin:0 auto;}/*!sc*/
.cyxuZC ul{height:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:left;-webkit-justify-content:left;-ms-flex-pack:left;justify-content:left;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;list-style:none;}/*!sc*/
.cyxuZC ul li + li{margin-left:32px;}/*!sc*/
.cyxuZC ul li a{color:var(--color-highlight);font-weight:600;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
@media (min-width:650px){.cyxuZC{max-width:calc(800px - (30px * 2));}}/*!sc*/
data-styled.g3[id="sc-gsDKAQ"]{content:"cyxuZC,"}/*!sc*/
.ealWIC{width:100vw;max-width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}/*!sc*/
data-styled.g13[id="sc-kDTinF"]{content:"ealWIC,"}/*!sc*/
.jHqaHV{margin:8% auto;width:90%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}/*!sc*/
.jHqaHV p,.jHqaHV blockquote,.jHqaHV ul,.jHqaHV ol,.jHqaHV dl,.jHqaHV table,.jHqaHV pre,.jHqaHV details{margin-top:0;margin-bottom:16px;}/*!sc*/
@media (min-width:650px){.jHqaHV{max-width:calc(800px - (30px * 2));}.jHqaHV h2{font-size:1.5rem;}}/*!sc*/
.jHqaHV h1{margin-bottom:4px;}/*!sc*/
.jHqaHV h2,.jHqaHV h3{margin-bottom:16px;margin-top:8px;}/*!sc*/
.jHqaHV p{font-size:1em;margin-bottom:16px;}/*!sc*/
.jHqaHV li{list-style:initial;}/*!sc*/
.jHqaHV li > p{margin-top:16px;}/*!sc*/
.jHqaHV li + li{margin-top:0.25em;}/*!sc*/
.jHqaHV ul,.jHqaHV ol{padding:0;list-style-type:none;}/*!sc*/
.jHqaHV ol[type='1']{list-style-type:decimal;}/*!sc*/
.jHqaHV ol[type='a']{list-style-type:lower-alpha;}/*!sc*/
.jHqaHV ol[type='i']{list-style-type:lower-roman;}/*!sc*/
.jHqaHV div > ol:not([type]){list-style-type:decimal;}/*!sc*/
.jHqaHV ul,.jHqaHV ol{margin-top:0;margin-bottom:0;padding-left:2em;}/*!sc*/
.jHqaHV ol ol,.jHqaHV ul ol{list-style-type:lower-roman;}/*!sc*/
.jHqaHV ul ul ol,.jHqaHV ul ol ol,.jHqaHV ol ul ol,.jHqaHV ol ol ol{list-style-type:lower-alpha;}/*!sc*/
.jHqaHV code{background:var(--color-code-background);border-radius:6px;font-size:95%;padding:0px 0.4em;}/*!sc*/
.jHqaHV code::-webkit-scrollbar,.jHqaHV pre::-webkit-scrollbar{height:4px;}/*!sc*/
@media (min-width:650px){.jHqaHV code::-webkit-scrollbar,.jHqaHV pre::-webkit-scrollbar{height:8px;}}/*!sc*/
.jHqaHV code::-webkit-scrollbar-track,.jHqaHV pre::-webkit-scrollbar-track{background:transparent;}/*!sc*/
.jHqaHV code::-webkit-scrollbar-thumb,.jHqaHV pre::-webkit-scrollbar-thumb{background:var(--color-code-background-complementary);border-radius:10px;}/*!sc*/
.jHqaHV pre code{font-size:0.9rem;}/*!sc*/
.jHqaHV pre{background:var(--color-code-background);overflow:auto;padding:16px 4px;border-radius:6px;font-size:12px;margin-top:0;margin-bottom:16px;}/*!sc*/
.jHqaHV pre code:not(.hljs){padding-left:0;}/*!sc*/
.jHqaHV a{margin-top:16px;}/*!sc*/
.jHqaHV a:last-of-type{margin-bottom:32px;}/*!sc*/
.jHqaHV ul,.jHqaHV ol{margin-top:0;margin-bottom:16px;padding-left:2em;}/*!sc*/
.jHqaHV blockquote{margin:0;padding:0 1em;color:var(--color-muted);border-left:0.25em solid var(--color-muted);}/*!sc*/
.jHqaHV h1,.jHqaHV h2,.jHqaHV h3,.jHqaHV h4,.jHqaHV h5,.jHqaHV h6{margin-top:36px;margin-bottom:16px;line-height:1.25;}/*!sc*/
.jHqaHV h1 tt,.jHqaHV h1 code,.jHqaHV h2 tt,.jHqaHV h2 code,.jHqaHV h3 tt,.jHqaHV h3 code,.jHqaHV h4 tt,.jHqaHV h4 code,.jHqaHV h5 tt,.jHqaHV h5 code,.jHqaHV h6 tt,.jHqaHV h6 code{padding:0 0.2em;font-size:inherit;}/*!sc*/
.jHqaHV table{border-spacing:0;border-collapse:collapse;display:block;width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:100%;overflow:auto;}/*!sc*/
.jHqaHV td,.jHqaHV th{padding:0;}/*!sc*/
.jHqaHV table th{font-weight:600;}/*!sc*/
.jHqaHV table th,.jHqaHV table td{padding:6px 13px;border:1px solid var(--color-muted);}/*!sc*/
.jHqaHV table tr{background-color:var(--color-canvas-default);border-top:1px solid var(--color-border-muted);}/*!sc*/
.jHqaHV table tr:nth-child(2n){background-color:var(--color-background-complementary);}/*!sc*/
.jHqaHV table img{background-color:transparent;}/*!sc*/
.jHqaHV hr{box-sizing:content-box;overflow:hidden;background:transparent;height:0.25em;padding:0;margin:24px 0;background-color:var(--color-background-complementary);border:0;}/*!sc*/
.jHqaHV hr::before{display:table;content:'';}/*!sc*/
.jHqaHV hr::after{display:table;clear:both;content:'';}/*!sc*/
data-styled.g14[id="sc-iqseJM"]{content:"jHqaHV,"}/*!sc*/
.irpEOD{display:block;width:100%;height:100%;color:var(--color-muted);margin-bottom:16px;}/*!sc*/
.irpEOD time,.irpEOD small{font-size:1em;}/*!sc*/
.irpEOD small{position:relative;margin-left:8px;}/*!sc*/
.irpEOD small::before{left:-6px;top:5%;content:'';position:absolute;width:1px;height:1em;background:var(--color-muted);}/*!sc*/
@media (min-width:650px){.irpEOD small::before{top:4%;}}/*!sc*/
data-styled.g15[id="sc-crHmcD"]{content:"irpEOD,"}/*!sc*/
.eknjSe{background:transparent;display:inline;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;border:none;}/*!sc*/
.eknjSe a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g16[id="sc-egiyK"]{content:"eknjSe,"}/*!sc*/
</style></head><body><div id="__next"><nav class="sc-bdvvtL cfTPtW"><div class="sc-gsDKAQ cyxuZC"><a href="/blog"><img src="/blog/logo.png" alt="logo" width="40" height="40"/></a><ul><li><a href="/blog/tags">Tags</a></li><li><a href="/blog/about">Sobre</a></li></ul></div></nav><div class="sc-kDTinF ealWIC"><article class="sc-iqseJM jHqaHV"><button class="sc-egiyK eknjSe"><a>‹ Voltar</a></button><h1> <!-- -->Corrigindo testes de unidade<!-- --> </h1><div class="sc-crHmcD irpEOD"><time> <!-- -->17 dez 2022<!-- --> </time><small> <!-- -->testes</small></div><main><h2>Introdução</h2>
<p>De tempos em tempos, eu volto nesse <a href="https://github.com/yudi-azvd/c-calculator">projeto</a>
para ler código, implementar novas funcionalidades ou corrigir bugs. É uma calculadora
de terminal em C que avalia expressões matemáticas bem simples.</p>
<p>Ao implementar essa calculadora, eu me propus a fazer testes unitários para aprender
boas práticas de programação e ter mais segurança do funcionamento correto das
funções desenvolvidas. Mal sabia eu que apenas escrever asserções sobre as expectativas
de resultados corretos não era o suficiente para escrever bons testes de unidade.
Um aspecto importante para escrever um bom teste de unidade é ter em mente qual
é a unidade sob teste. Dessa parte eu sabia, mas não estava convicto, o que acabou
resultando depois em dor de cabeça desnecessária.</p>
<h2>Funcionamento básico da calculadora</h2>
<p>Ela funciona em um ciclo executando algumas etapas mais ou menos assim:</p>
<ol>
<li>Ler a entrada do usuário</li>
<li>Validar e sanitizar</li>
<li>Tokenizar</li>
<li>Avaliar</li>
<li>Mostrar o resultado para o usuário e repetir.</li>
</ol>
<p>O foco deste post é nas etapas 3 e 4.</p>
<p><strong>Tokenizar</strong>, nesse contexto, é separar as partes siginificativas de uma expressão
matemática em tokens como números, operadores e parênteses de abertura e de
fechamento. Essa etapa é executada pela função <code>tokenize</code>.</p>
<p><strong>Avaliar</strong> é a etapa de simplificar uma expressão matemática em seu resultado.
Por exemplo, <code>3 + 3 * 2</code> tem <code>9</code> como resultado. A função responsável por essa
etapa é <code>evaluate</code>.</p>
<h2>O teste de "unidade"</h2>
<p>Nesse projeto foi usado <a href="https://github.com/catchorg/Catch2">Catch</a> para
escrever os testes de unidade. Dentre eles, existe o arquivo <code>evaluate.test.cpp</code>,
que contém o seguinte caso de teste:</p>
<pre><code class="hljs language-cpp"><span class="hljs-built_in">TEST_CASE</span>(<span class="hljs-string">"evaluate 0"</span>, <span class="hljs-string">"[evaluate]"</span>) {
  <span class="hljs-type">char</span>* data;
  <span class="hljs-type">char</span>* result;
  t_list* list;

  <span class="hljs-type">char</span> expression[] = <span class="hljs-string">"3*(8+4)/2"</span>;

  list = <span class="hljs-built_in">tokenize</span>(expression);

  <span class="hljs-built_in">evaluate</span>(list, &#x26;result);
  <span class="hljs-built_in">REQUIRE</span>(<span class="hljs-built_in">string</span>(result) == <span class="hljs-string">"18.000000"</span>);
  <span class="hljs-comment">// Tem mais código que que libera memória,</span>
  <span class="hljs-comment">// mas será omitido daqui pra frente.</span>
}
</code></pre>
<p>Baseado no nome do arquivo e no conteúdo do caso de teste, qual é a unidade sob
teste?</p>
<p>Se sua repostas foi <code>evaluate</code>, você acertou. Na época que eu escrevi esse teste
pela primeira vez, minha intenção era que ele fosse um teste de unidade.</p>
<p>Se você é experiente com testes, você percebeu que esse teste, na realidade, não
é um teste de unidade porque ele também depende do funcionamento correto da
função <code>tokenize</code>. Um caso de teste que ilustra isso é o <code>"3*3-6/2"</code>, que
resulta na <a href="https://github.com/yudi-azvd/c-calculator/issues/2">falha do teste</a>.</p>
<p>Fiquei um tempo considerável procurando a origem do erro na função <code>evaluate</code>.
Talvez não seja surpresa para você que está lendo agora, mas
<a href="https://github.com/yudi-azvd/c-calculator/issues/2#issuecomment-1039256295">descobri depois</a>
que o erro estava na verdade na função <code>tokenize</code>.</p>
<h2>Correção do teste</h2>
<p>O ideal é que o sucesso do caso de teste dependa apenas da função sob teste,
nesse contexto, <code>evaluate</code>. Vamos lembrar que essa função precisa de uma lista
em que cada elemento seja um token para avaliar o resultado da expressão que ela
representa.</p>
<p>Para corrigir o teste, precisamos de alguma rotina auxiliar, mais simples que
<code>tokenize</code>, que transforme uma expressão do tipo <code>"3*3-6/2"</code> em uma lista de
tokens. E precisamos fazer isso sem usar a função <code>tokenize</code> porque ela faz parte
da lógica principal da calculadora e deve ser testada em outro lugar.</p>
<p>A forma que eu escolhi para fazer isso foi assim:</p>
<pre><code class="hljs language-cpp"><span class="hljs-function">t_list* <span class="hljs-title">create_char_list_from</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span> </span>{
  t_list* l = <span class="hljs-built_in">create_list</span>(<span class="hljs-string">"char*"</span>);

  <span class="hljs-type">char</span>* delimeters = <span class="hljs-string">" \t\n"</span>;
  <span class="hljs-type">char</span>* last_token_found = <span class="hljs-built_in">strtok</span>(str, delimeters);
  <span class="hljs-comment">// strtok modifica o seu primeiro parâmetro, use com cuidado!</span>
  <span class="hljs-keyword">while</span> (last_token_found != <span class="hljs-literal">NULL</span>) {
    <span class="hljs-type">char</span>* s = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">strlen</span>(last_token_found)+<span class="hljs-number">1</span>);
    <span class="hljs-built_in">strcpy</span>(s, last_token_found);
    <span class="hljs-built_in">insert_tail</span>(l, s);
    last_token_found = <span class="hljs-built_in">strtok</span>(<span class="hljs-literal">NULL</span>, delimeters);
  }

  <span class="hljs-keyword">return</span> l;
}
</code></pre>
<p>(A criação dessa função foi uma adaptação desse
<a href="https://www.cplusplus.com/reference/cstring/strtok/">exemplo</a>)</p>
<p><code>create_char_list_from</code> cria uma lista encadeada de strings a partir de uma string,
separando os elementos por espaço em branco.
Na terra do C, a gente tem que implementar algumas rotinas por conta própria mesmo.
Se você usa outra linguagem mais moderna, não se preocupe com essa parte.
Apenas considere que <code>create_char_list_from</code> funciona de forma semelhante ao
método <code>split</code> do
<a href="https://docs.python.org/3.3/library/stdtypes.html?highlight=split#str.split">Python</a>
ou do
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-">Java</a>.</p>
<p>Exemplo de string de entrada: <code>"3 * ( 8 + 4 ) / 2"</code>. Essa entrada deve causar o
retorno de uma lista encadeada com os elementos:</p>
<p><code>3, *, (, 8, +, 4, ), /, 2</code></p>
<p>Reescrevendo o caso de teste com a função <code>create_char_list_from</code> temos o seguinte:</p>
<pre><code class="hljs language-cpp"><span class="hljs-built_in">TEST_CASE</span>(<span class="hljs-string">"evaluate 0"</span>, <span class="hljs-string">"[evaluate]"</span>) {
  <span class="hljs-type">char</span>* data;
  <span class="hljs-type">char</span>* result;
  t_list* list;

  <span class="hljs-type">char</span> expression[] = <span class="hljs-string">" 3 * ( 8 + 4 ) / 2"</span>;
  list = <span class="hljs-built_in">create_char_list_from</span>(expression);

  <span class="hljs-built_in">evaluate</span>(list, &#x26;result);
  <span class="hljs-built_in">REQUIRE</span>(<span class="hljs-built_in">string</span>(result) == <span class="hljs-string">"18.000000"</span>);
}
</code></pre>
<p>Antes, o sucesso do caso de teste dependia de duas etapas importantes e
relativamente complexas do ciclo da calculadora. Depois da correção, ele depende
de apenas uma etapa da calculadora (a unidade sob teste) e de uma função auxiliar
relativamente simples que <em>não</em> faz parte da lógica principal da calculadora.</p>
<h2>Conclusão</h2>
<p>Não deixe a preguiça atingir você, pense um pouco sobre como você está escrevendo
seus testes. Independemente se a unidade sob teste for uma classe, método ou
função, o seu sucesso deve depender apenas dessa unidade.</p>
<h3>Observações tangentes</h3>
<ul>
<li>Escrevendo esse post eu percebi que havia um bug em <code>create_char_list_from</code>.
Por isso, vale reforçar que é importante testar as funções auxiliares que você
escreve.</li>
<li>Não use o código do repositório para entender as funções. No momento em que você
acessar o link, o código provavelmente já mudou. O que está escrito neste post
deve ser o suficiente para entender o que estou tentado dizer.</li>
<li>Não use os nomes dos testes como eu fiz. Eu era jovem e preguiçoso. Dê nomes
descritivos para os seus casos de teste. Assista esse
<a href="https://youtu.be/MWsk1h8pv2Q?t=892">trecho</a> para ter uma ideia de como escolher
bons nomes.</li>
<li>A função <code>evaluate</code> ainda não é totalmente isolável porque ela utiliza internamente
a função <code>to_postfix</code> que converte uma expressão na forma
<a href="https://en.wikipedia.org/wiki/Infix_notation">infixa</a> para
<a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">pós-fixa</a>. Essa conversão
é um pré-requisito para avaliação de uma expressão e, por isso, talvez seja
interessante separar essas duas funções e testá-las isoladamente.</li>
</ul></main><button class="sc-egiyK eknjSe"><a>‹ Voltar</a></button></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"2022/2022-12-17-corrigindo-testes-de-unidade","slug":"corrigindo-testes-de-unidade","date":"2022-12-17","dateFormatted":"17 dez 2022","content":"\u003ch2\u003eIntrodução\u003c/h2\u003e\n\u003cp\u003eDe tempos em tempos, eu volto nesse \u003ca href=\"https://github.com/yudi-azvd/c-calculator\"\u003eprojeto\u003c/a\u003e\npara ler código, implementar novas funcionalidades ou corrigir bugs. É uma calculadora\nde terminal em C que avalia expressões matemáticas bem simples.\u003c/p\u003e\n\u003cp\u003eAo implementar essa calculadora, eu me propus a fazer testes unitários para aprender\nboas práticas de programação e ter mais segurança do funcionamento correto das\nfunções desenvolvidas. Mal sabia eu que apenas escrever asserções sobre as expectativas\nde resultados corretos não era o suficiente para escrever bons testes de unidade.\nUm aspecto importante para escrever um bom teste de unidade é ter em mente qual\né a unidade sob teste. Dessa parte eu sabia, mas não estava convicto, o que acabou\nresultando depois em dor de cabeça desnecessária.\u003c/p\u003e\n\u003ch2\u003eFuncionamento básico da calculadora\u003c/h2\u003e\n\u003cp\u003eEla funciona em um ciclo executando algumas etapas mais ou menos assim:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eLer a entrada do usuário\u003c/li\u003e\n\u003cli\u003eValidar e sanitizar\u003c/li\u003e\n\u003cli\u003eTokenizar\u003c/li\u003e\n\u003cli\u003eAvaliar\u003c/li\u003e\n\u003cli\u003eMostrar o resultado para o usuário e repetir.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eO foco deste post é nas etapas 3 e 4.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTokenizar\u003c/strong\u003e, nesse contexto, é separar as partes siginificativas de uma expressão\nmatemática em tokens como números, operadores e parênteses de abertura e de\nfechamento. Essa etapa é executada pela função \u003ccode\u003etokenize\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAvaliar\u003c/strong\u003e é a etapa de simplificar uma expressão matemática em seu resultado.\nPor exemplo, \u003ccode\u003e3 + 3 * 2\u003c/code\u003e tem \u003ccode\u003e9\u003c/code\u003e como resultado. A função responsável por essa\netapa é \u003ccode\u003eevaluate\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eO teste de \"unidade\"\u003c/h2\u003e\n\u003cp\u003eNesse projeto foi usado \u003ca href=\"https://github.com/catchorg/Catch2\"\u003eCatch\u003c/a\u003e para\nescrever os testes de unidade. Dentre eles, existe o arquivo \u003ccode\u003eevaluate.test.cpp\u003c/code\u003e,\nque contém o seguinte caso de teste:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-built_in\"\u003eTEST_CASE\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"evaluate 0\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"[evaluate]\"\u003c/span\u003e) {\n  \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e* data;\n  \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e* result;\n  t_list* list;\n\n  \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e expression[] = \u003cspan class=\"hljs-string\"\u003e\"3*(8+4)/2\"\u003c/span\u003e;\n\n  list = \u003cspan class=\"hljs-built_in\"\u003etokenize\u003c/span\u003e(expression);\n\n  \u003cspan class=\"hljs-built_in\"\u003eevaluate\u003c/span\u003e(list, \u0026#x26;result);\n  \u003cspan class=\"hljs-built_in\"\u003eREQUIRE\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e(result) == \u003cspan class=\"hljs-string\"\u003e\"18.000000\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// Tem mais código que que libera memória,\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// mas será omitido daqui pra frente.\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBaseado no nome do arquivo e no conteúdo do caso de teste, qual é a unidade sob\nteste?\u003c/p\u003e\n\u003cp\u003eSe sua repostas foi \u003ccode\u003eevaluate\u003c/code\u003e, você acertou. Na época que eu escrevi esse teste\npela primeira vez, minha intenção era que ele fosse um teste de unidade.\u003c/p\u003e\n\u003cp\u003eSe você é experiente com testes, você percebeu que esse teste, na realidade, não\né um teste de unidade porque ele também depende do funcionamento correto da\nfunção \u003ccode\u003etokenize\u003c/code\u003e. Um caso de teste que ilustra isso é o \u003ccode\u003e\"3*3-6/2\"\u003c/code\u003e, que\nresulta na \u003ca href=\"https://github.com/yudi-azvd/c-calculator/issues/2\"\u003efalha do teste\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFiquei um tempo considerável procurando a origem do erro na função \u003ccode\u003eevaluate\u003c/code\u003e.\nTalvez não seja surpresa para você que está lendo agora, mas\n\u003ca href=\"https://github.com/yudi-azvd/c-calculator/issues/2#issuecomment-1039256295\"\u003edescobri depois\u003c/a\u003e\nque o erro estava na verdade na função \u003ccode\u003etokenize\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eCorreção do teste\u003c/h2\u003e\n\u003cp\u003eO ideal é que o sucesso do caso de teste dependa apenas da função sob teste,\nnesse contexto, \u003ccode\u003eevaluate\u003c/code\u003e. Vamos lembrar que essa função precisa de uma lista\nem que cada elemento seja um token para avaliar o resultado da expressão que ela\nrepresenta.\u003c/p\u003e\n\u003cp\u003ePara corrigir o teste, precisamos de alguma rotina auxiliar, mais simples que\n\u003ccode\u003etokenize\u003c/code\u003e, que transforme uma expressão do tipo \u003ccode\u003e\"3*3-6/2\"\u003c/code\u003e em uma lista de\ntokens. E precisamos fazer isso sem usar a função \u003ccode\u003etokenize\u003c/code\u003e porque ela faz parte\nda lógica principal da calculadora e deve ser testada em outro lugar.\u003c/p\u003e\n\u003cp\u003eA forma que eu escolhi para fazer isso foi assim:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-function\"\u003et_list* \u003cspan class=\"hljs-title\"\u003ecreate_char_list_from\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e* str)\u003c/span\u003e \u003c/span\u003e{\n  t_list* l = \u003cspan class=\"hljs-built_in\"\u003ecreate_list\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"char*\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e* delimeters = \u003cspan class=\"hljs-string\"\u003e\" \\t\\n\"\u003c/span\u003e;\n  \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e* last_token_found = \u003cspan class=\"hljs-built_in\"\u003estrtok\u003c/span\u003e(str, delimeters);\n  \u003cspan class=\"hljs-comment\"\u003e// strtok modifica o seu primeiro parâmetro, use com cuidado!\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (last_token_found != \u003cspan class=\"hljs-literal\"\u003eNULL\u003c/span\u003e) {\n    \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e* s = \u003cspan class=\"hljs-built_in\"\u003ecalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003estrlen\u003c/span\u003e(last_token_found)+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n    \u003cspan class=\"hljs-built_in\"\u003estrcpy\u003c/span\u003e(s, last_token_found);\n    \u003cspan class=\"hljs-built_in\"\u003einsert_tail\u003c/span\u003e(l, s);\n    last_token_found = \u003cspan class=\"hljs-built_in\"\u003estrtok\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003eNULL\u003c/span\u003e, delimeters);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e l;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(A criação dessa função foi uma adaptação desse\n\u003ca href=\"https://www.cplusplus.com/reference/cstring/strtok/\"\u003eexemplo\u003c/a\u003e)\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecreate_char_list_from\u003c/code\u003e cria uma lista encadeada de strings a partir de uma string,\nseparando os elementos por espaço em branco.\nNa terra do C, a gente tem que implementar algumas rotinas por conta própria mesmo.\nSe você usa outra linguagem mais moderna, não se preocupe com essa parte.\nApenas considere que \u003ccode\u003ecreate_char_list_from\u003c/code\u003e funciona de forma semelhante ao\nmétodo \u003ccode\u003esplit\u003c/code\u003e do\n\u003ca href=\"https://docs.python.org/3.3/library/stdtypes.html?highlight=split#str.split\"\u003ePython\u003c/a\u003e\nou do\n\u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-\"\u003eJava\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eExemplo de string de entrada: \u003ccode\u003e\"3 * ( 8 + 4 ) / 2\"\u003c/code\u003e. Essa entrada deve causar o\nretorno de uma lista encadeada com os elementos:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e3, *, (, 8, +, 4, ), /, 2\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eReescrevendo o caso de teste com a função \u003ccode\u003ecreate_char_list_from\u003c/code\u003e temos o seguinte:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-built_in\"\u003eTEST_CASE\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"evaluate 0\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"[evaluate]\"\u003c/span\u003e) {\n  \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e* data;\n  \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e* result;\n  t_list* list;\n\n  \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e expression[] = \u003cspan class=\"hljs-string\"\u003e\" 3 * ( 8 + 4 ) / 2\"\u003c/span\u003e;\n  list = \u003cspan class=\"hljs-built_in\"\u003ecreate_char_list_from\u003c/span\u003e(expression);\n\n  \u003cspan class=\"hljs-built_in\"\u003eevaluate\u003c/span\u003e(list, \u0026#x26;result);\n  \u003cspan class=\"hljs-built_in\"\u003eREQUIRE\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e(result) == \u003cspan class=\"hljs-string\"\u003e\"18.000000\"\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAntes, o sucesso do caso de teste dependia de duas etapas importantes e\nrelativamente complexas do ciclo da calculadora. Depois da correção, ele depende\nde apenas uma etapa da calculadora (a unidade sob teste) e de uma função auxiliar\nrelativamente simples que \u003cem\u003enão\u003c/em\u003e faz parte da lógica principal da calculadora.\u003c/p\u003e\n\u003ch2\u003eConclusão\u003c/h2\u003e\n\u003cp\u003eNão deixe a preguiça atingir você, pense um pouco sobre como você está escrevendo\nseus testes. Independemente se a unidade sob teste for uma classe, método ou\nfunção, o seu sucesso deve depender apenas dessa unidade.\u003c/p\u003e\n\u003ch3\u003eObservações tangentes\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eEscrevendo esse post eu percebi que havia um bug em \u003ccode\u003ecreate_char_list_from\u003c/code\u003e.\nPor isso, vale reforçar que é importante testar as funções auxiliares que você\nescreve.\u003c/li\u003e\n\u003cli\u003eNão use o código do repositório para entender as funções. No momento em que você\nacessar o link, o código provavelmente já mudou. O que está escrito neste post\ndeve ser o suficiente para entender o que estou tentado dizer.\u003c/li\u003e\n\u003cli\u003eNão use os nomes dos testes como eu fiz. Eu era jovem e preguiçoso. Dê nomes\ndescritivos para os seus casos de teste. Assista esse\n\u003ca href=\"https://youtu.be/MWsk1h8pv2Q?t=892\"\u003etrecho\u003c/a\u003e para ter uma ideia de como escolher\nbons nomes.\u003c/li\u003e\n\u003cli\u003eA função \u003ccode\u003eevaluate\u003c/code\u003e ainda não é totalmente isolável porque ela utiliza internamente\na função \u003ccode\u003eto_postfix\u003c/code\u003e que converte uma expressão na forma\n\u003ca href=\"https://en.wikipedia.org/wiki/Infix_notation\"\u003einfixa\u003c/a\u003e para\n\u003ca href=\"https://en.wikipedia.org/wiki/Reverse_Polish_notation\"\u003epós-fixa\u003c/a\u003e. Essa conversão\né um pré-requisito para avaliação de uma expressão e, por isso, talvez seja\ninteressante separar essas duas funções e testá-las isoladamente.\u003c/li\u003e\n\u003c/ul\u003e","title":"Corrigindo testes de unidade","tags":["testes"],"excerpt":"Um aspecto importante para escrever um bom teste de\nunidade é ter em mente qual é a unidade sob teste\n","description":"Ao implementar essa calculadora, eu me propus a fazer testes unitários para\naprender boas práticas de programação e ter mais segurança do funcionamento\ncorreto das funções desenvolvidas. Mal sabia eu que apenas escrever asserções\nsobre as expectativas de resultados corretos não era o suficiente para escrever\nbons testes de unidade. Um aspecto importante para escrever um bom teste de\nunidade é ter em mente qual é a unidade sob teste. Dessa parte eu sabia, mas\nnão estava convicto, o que acabou resultando depois em dor de cabeça\ndesnecessária.\n"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"corrigindo-testes-de-unidade"},"buildId":"7BjNWWaJAhJp2ApepI5-W","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>