{"pageProps":{"post":{"id":"2021/2021-12-19-ler-do-sistema-de-arquivos-em-c-organizado","slug":"ler-do-sistema-de-arquivos-em-c-organizado","date":"2021-12-19","dateFormatted":"19 de dez. de 2021","content":"<h2>Pré-requisitos</h2>\n<ul>\n<li>Ambiente Linux com GCC</li>\n<li>Conhecimento de ponteiros e strings em C</li>\n</ul>\n<p>Aprendizados:</p>\n<ul>\n<li><code>getcwd</code></li>\n<li><code>strcat</code></li>\n<li><code>strstr</code></li>\n</ul>\n<h2>Poblema</h2>\n<p>Para a disciplina de Estrutura de Dados 2 (EDA2), eu tenho um\n<a href=\"https://github.com/yudi-azvd/eda2/\">repositório</a> com uma estrutura relativamente\ncomplexa para um \"projeto\" em C. Esse repositório vive no meu computador na\npasta <code>/home/yudi/&#x3C;vários diretórios>/eda2/</code>, mais ou menos com o seguinte conteúdo:</p>\n<pre><code>.\n├── ... outros arquivos como .gitignore, README.md, etc\n├── 00-revisao/\n├── 01-sorting/\n├── 02-hash/\n├── 04-trees/\n├── 05-heap/\n├── 06-graph\n│   ├── _exercises/\n│   └── list-und-graph\n│       ├── listundgraph.h\n│       └── _tests\n│           ├── listundgraph.test.cpp\n│           └── ...\n└── resources\n    └── algs4-data\n        ├── tinyG.txt\n        ├── tinyCG.txt\n        └── ... outros vários arquivos com amostras de dados\n</code></pre>\n<p>Em um dos exercícios do livro, eu tinha que criar um\n\"<a href=\"https://pt.wikipedia.org/wiki/Construtor\">construtor</a>\" que recebe o caminho\nde um arquivo para criar e preencher o grafo, com uma assinatura assim:</p>\n<pre><code class=\"hljs language-c\">ListUndGraph *<span class=\"hljs-title hljs-function\">ListUndGraph_create_from_file</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *filepath)</span>\n</code></pre>\n<p>Que é chamada nos arquivos em <code>06-graph/list-und-graph/_tests/</code> ou\nem <code>06-graph/_exercises/</code>.</p>\n<h2>Primeiras soluções</h2>\n<p>A primeira solução que pensei foi a de passar o caminho relativo para o construtor,\nalgo como <code>\"../../../../resources/algs4-data/tinyG.txt\"</code>. A quantidade de <code>../</code>\nvaria de acordo com o lugar de onde <code>ListUndGraph_create_from_file</code> é chamado.\nEssa é uma solução viável, mas um tanto incoveniente. O código cliente fica feio\ncom muitos <code>../</code> e é chato para o programador ficar \"calculando\" essa quantidade.</p>\n<p>Outra solução seria passar o caminho absoluto para o construtor. No meu computador,\npor exemplo, esse caminho poderia ser\n<code>\"/home/yudi/uni/eda2/resources/algs4-data/tinyG.txt\"</code>. Essa solução, entretanto,\ntraz mais restrições:</p>\n<ul>\n<li>Se por acaso eu precisar mudar o repositório de lugar no meu computador, esse\ncaminho absoluto já não valeria mais</li>\n<li>Se outra pessoa baixar esse repositório no computador dela, esse caminho absoluto\nfaria menos sentido ainda. Ela teria que ter um username igual a <code>yudi</code> e\nbaixar o repositório em <code>~/uni/</code></li>\n<li>Essa solução polui o projeto com informações do sistema de arquivos que estão\nfora do repositório e não importam pra ele.</li>\n</ul>\n<h2>Uma solução melhor</h2>\n<p><em>Ao meu ver pelo menos.</em></p>\n<p>Para o cliente, seria interessante se a chamada do construtor fosse algo assim:</p>\n<pre><code class=\"hljs language-c\">ListUndGraph *g = ListUndGraph_create_from_file(<span class=\"hljs-string\">\"algs4-data/tinyG.txt\"</span>);\n</code></pre>\n<p>Dessa maneira, o construtor recebe apenas o <em>caminho relativo</em> para o arquivo a\npartir de <code>resources/</code> e ele se encarrega de resolver o <em>caminho absoluto</em> até a\npasta <code>resources/</code> ou de chamar alguém que sabe fazê-lo.</p>\n<p>Vamos optar por criar a função <code>void get_res_dir(char *res_dir)</code> que preenche\n<code>res_dir</code> com o caminho absoluto até <code>resources/</code> e é usada pelo construtor. Como\nbônus, ela ainda pode ser usada por outras funções de qualquer lugar do repositório\ne sua lógica pode ser reaproveitada em outros projetos.</p>\n<p>Como vamos colocar <code>get_res_dir</code> em seu próprio arquivo de cabeçalho (<code>.h</code>), ele\nprecisa ser incluído por quem quer usá-lo. Infelizmente, o problema da quantidade\n<code>../</code> volta aqui na hora de usar <code>#include \"../../../get_res_dir.h\"</code>. Isso pode\nser resolvido com um Makefile ou com um gerador de build system. Configurando\nessas ferramentas apropriadamente, a compilação por debaixo dos panos aconteceria\nmais ou menos assim:</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># essa quantidade de \"../\" é apenas para ilustração.</span>\ngcc -I<span class=\"hljs-string\">\"../../../../get_res_dir.h\"</span> listundgraph.test.cpp -o listundgraph.test.out\n</code></pre>\n<p>Assim seria possível incluir a função apenas com</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"get_res_dir.h\"</span></span>\n</code></pre>\n<p>Eu teria que pesquisar mais pra configurar essas ferramentas apropriadamente, mas\ndurante o curso de EDA2 eu não achei necessário fazer o setup de Make ou CMake\npara esses exercícios simples <del>por preguiça ou falta de paciência pra aprender</del>.\nAinda assim, vale ressaltar que essa estratégia seria mais adequada em um projeto\nC/C++ de verdade .</p>\n<h2>Super pseudocódigo</h2>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">get_res_dir</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* res_dir)</span> </span>{\n  <span class=\"hljs-comment\">// pegar caminho absoluto do diretório onde o programa está sendo executado</span>\n  <span class=\"hljs-comment\">//    exemplo: \"/home/yudi/uni/eda2/06-graph/list-und-graph/_tests/\"</span>\n  <span class=\"hljs-comment\">// pegar a substring do caminho absoluto até \"eda2\"</span>\n  <span class=\"hljs-comment\">//   substr: \"/home/yudi/uni/eda2/\"</span>\n  <span class=\"hljs-comment\">// concatenar a substring com \"resources/\"</span>\n  <span class=\"hljs-comment\">//   resultado: \"/home/yudi/uni/eda2/resources/\"</span>\n  <span class=\"hljs-comment\">// (esse resultado deve estar em res_dir no final da função)</span>\n}\n</code></pre>\n<h2>Implementação de <code>get_res_dir</code></h2>\n<p>Para pegar o caminho absoluto do diretório eu pesquisei extamente isso no Google.\nComo estou programando em ambiente Linux, a função que foi recomendada foi\n<code>char* getcwd(char* buf, size_t size)</code> (get current working directory) do cabeçalho\n<code>unistd.h</code>. De acordo com as\n<a href=\"https://man7.org/linux/man-pages/man3/getcwd.3.html\">páginas do manual</a>, ela retorna\no diretório em <code>buf</code>, que deve apontar para um espaço previamente alocado.</p>\n<p>Executando a essa função no meu computador no diretório\n<code>/home/yudi/uni/eda2/06-graph/list-und-graph/_tests/</code>, ela retorna exatamente isso.\nPor prevenção, vamos usar um buffer com o tamanho máximo.</p>\n<pre><code class=\"hljs language-c\">getcwd(res_dir, PATH_MAX);\n</code></pre>\n<p>Agora precisamos apenas de uma substring disso tudo: <code>\"/home/yudi/uni/eda2\"</code>. Como\ndiretório raíz do repositório, podemos usar a string <code>\"eda2\"</code> para extrair a\nsubstring de interesse. É uma suposição razoável porque é o nome do repositório\ne dificilmente vai mudar. Uma solução mais robusta, talvez, seria procurar o próximo\ndiretório pai com a pasta <code>.git</code>, mas não vamos por esse caminho nesse post.</p>\n<p>Para extrair a substring, vamos usar a função</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-type\">char</span>* <span class=\"hljs-title hljs-function\">strstr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *haystack, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *needle)</span>\n</code></pre>\n<p>Que encontra a primeira ocorrência de <code>needle</code> em <code>haystack</code> e retorna o ponteiro\nque aponta para onde <code>needle</code> foi encontrado.</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *root_dir_name = <span class=\"hljs-string\">\"eda2\"</span>;\n<span class=\"hljs-type\">char</span> *root_dir_ptr = <span class=\"hljs-built_in\">strstr</span>(res_dir, root_dir_name);\n</code></pre>\n<p>Agora <code>root_dir_ptr</code> aponta para a string <code>\"eda2/06-graph/list-und-graph/_tests\"</code>.\nVale ressaltar que não há cópias de strings, <code>root_dir_ptr</code> apenas aponta para\numa região de memória alguns bytes à frente da região de memória apontada por\n<code>res_dir</code>, conforme a ilustração abaixo:</p>\n<pre><code>/home/yudi/uni/eda2/06-graph/list-und-graph/_tests/\n↑              ↑\nres_dir        root_dir_ptr\n</code></pre>\n<p>Como não precisamos de nada que vem depois de <code>\"eda2/\"</code>, podemos desconsiderar\nessa parte colocando o terminador de string <code>'\\0'</code>.</p>\n<pre><code class=\"hljs language-c\">*(root_dir_ptr + <span class=\"hljs-built_in\">strlen</span>(root_dir_name)) = <span class=\"hljs-string\">'\\0'</span>;\n</code></pre>\n<p>Agora <code>res_dir</code> aponta para</p>\n<pre><code>                   Note o '\\0', antes era um '/'\n                   ↓\n/home/yudi/uni/eda2\\006-graph/list-und-graph/_tests/\n↑              ↑\nres_dir        root_dir_ptr\n\n</code></pre>\n<p>Que é o mesmo que:</p>\n<pre><code>\n/home/yudi/uni/eda2\n↑              ↑\nres_dir        root_dir_ptr\n</code></pre>\n<p>Agora só precisamos concatenar <code>\"/resources\"</code> ao final de <code>res_dir</code>:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *res = <span class=\"hljs-string\">\"/resources\"</span>;\n<span class=\"hljs-built_in\">strcat</span>(res_dir, res);\n</code></pre>\n<p>Juntando tudo, a função <code>get_res_dir</code> fica assim:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;unistd.h></span>       <span class=\"hljs-comment\">// getcwd</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;linux/limits.h></span> <span class=\"hljs-comment\">// PATH_MAX</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;string.h></span>       <span class=\"hljs-comment\">// strstr, strcat, strlen</span></span>\n\n<span class=\"hljs-comment\">// Preenche RES_DIR com \"/.../eda2/resources\".</span>\n<span class=\"hljs-comment\">// \"...\" é o caminho absoluto até \"eda2/\".</span>\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// RES_DIR deve ser um buffer com PATH_MAX bytes.</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title hljs-function\">get_res_dir</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> *res_dir)</span>\n{\n  getcwd(res_dir, PATH_MAX);\n  <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *root_dir_name = <span class=\"hljs-string\">\"eda2\"</span>;\n  <span class=\"hljs-type\">char</span> *root_dir_ptr = <span class=\"hljs-built_in\">strstr</span>(res_dir, root_dir_name);\n  *(root_dir_ptr + <span class=\"hljs-built_in\">strlen</span>(root_dir_name)) = <span class=\"hljs-string\">'\\0'</span>;\n  <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *res = <span class=\"hljs-string\">\"/resources\"</span>;\n  <span class=\"hljs-built_in\">strcat</span>(res_dir, res);\n}\n</code></pre>\n<h2>Implementação de <code>ListUndGraph_create_from_file</code></h2>\n<p>Agora só falta implementar o construtor de grafos. Vamos alocar um espaço para\no caminho absoluto.</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-type\">char</span> full_filepath[PATH_MAX]; <span class=\"hljs-comment\">// com lixo de memória por enquanto</span>\n</code></pre>\n<p>Executando a função <code>get_res_dir</code> com <code>full_filepath</code> obtemos o seguinte:</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-built_in\">get_res_dir</span>(full_filepath);\n<span class=\"hljs-comment\">// full_filepath: \"/home/yudi/uni/eda2/resources\"</span>\n</code></pre>\n<p>Para terminar, precisamos acrescentar uma <code>\"/\"</code> e o caminho relativo do arquivo\nque foi passado a <code>ListUndGraph_create_from_file</code>. Vamos supor que esse caminho\nrelativo é <code>\"algs4-data/tinyG.txt\"</code>.</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-comment\">// full_filepath: \"/home/yudi/uni/eda2/resources\"</span>\n<span class=\"hljs-built_in\">strcat</span>(full_filepath, <span class=\"hljs-string\">\"/\"</span>);\n<span class=\"hljs-comment\">// full_filepath: \"/home/yudi/uni/eda2/resources/\"</span>\n<span class=\"hljs-built_in\">strcat</span>(full_filepath, filepath);\n<span class=\"hljs-comment\">// full_filepath: \"/home/yudi/uni/eda2/resources/algs4-data/tinyG.txt\"</span>\n</code></pre>\n<p>O código do construtor fica assim:</p>\n<pre><code class=\"hljs language-c\">ListUndGraph *<span class=\"hljs-title hljs-function\">ListUndGraph_create_from_file</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *filepath)</span>\n{\n  <span class=\"hljs-type\">char</span> full_filepath[PATH_MAX];\n  get_res_dir(full_filepath);\n  <span class=\"hljs-built_in\">strcat</span>(full_filepath, <span class=\"hljs-string\">\"/\"</span>);\n  <span class=\"hljs-built_in\">strcat</span>(full_filepath, filepath);\n\n  <span class=\"hljs-comment\">// restante do código para preencher o grafo</span>\n}\n</code></pre>\n<h2>Possíveis melhorias</h2>\n<p>Ainda seria possível deixar <code>ListUndGraph_create_from_file</code> mais interessante,\ncriando uma função que faz o equivalente às últimas três linhas do trecho\nanterior.</p>\n<p>Outra melhoria seria deixar esse código um pouco mais cross-platform, ou seja,\nque funcione melhor independentemente do sistema operacional. O cabeçalho\n<code>unistd.h</code> não existe em Windows, o que geraria um erro de compilação. Uma\nmaneira de resolver isso seria com macros condicionais e usando a função\n<code>GetCurrentDirectory</code> do cabeçalho <code>winbase.h</code>.</p>\n<p>Essas possíveis melhorias ficam como exercícios para leitor.</p>","title":"Como ler do sistema de arquivos de um jeito organizado em C","tags":["c","sistema-de-arquivos"],"excerpt":"Usando getcwd, strcat e strstr"}},"__N_SSG":true}