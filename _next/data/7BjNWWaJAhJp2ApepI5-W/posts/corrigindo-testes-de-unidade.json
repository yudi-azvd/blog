{"pageProps":{"post":{"id":"2022/2022-12-17-corrigindo-testes-de-unidade","slug":"corrigindo-testes-de-unidade","date":"2022-12-17","dateFormatted":"17 dez 2022","content":"<h2>Introdução</h2>\n<p>De tempos em tempos, eu volto nesse <a href=\"https://github.com/yudi-azvd/c-calculator\">projeto</a>\npara ler código, implementar novas funcionalidades ou corrigir bugs. É uma calculadora\nde terminal em C que avalia expressões matemáticas bem simples.</p>\n<p>Ao implementar essa calculadora, eu me propus a fazer testes unitários para aprender\nboas práticas de programação e ter mais segurança do funcionamento correto das\nfunções desenvolvidas. Mal sabia eu que apenas escrever asserções sobre as expectativas\nde resultados corretos não era o suficiente para escrever bons testes de unidade.\nUm aspecto importante para escrever um bom teste de unidade é ter em mente qual\né a unidade sob teste. Dessa parte eu sabia, mas não estava convicto, o que acabou\nresultando depois em dor de cabeça desnecessária.</p>\n<h2>Funcionamento básico da calculadora</h2>\n<p>Ela funciona em um ciclo executando algumas etapas mais ou menos assim:</p>\n<ol>\n<li>Ler a entrada do usuário</li>\n<li>Validar e sanitizar</li>\n<li>Tokenizar</li>\n<li>Avaliar</li>\n<li>Mostrar o resultado para o usuário e repetir.</li>\n</ol>\n<p>O foco deste post é nas etapas 3 e 4.</p>\n<p><strong>Tokenizar</strong>, nesse contexto, é separar as partes siginificativas de uma expressão\nmatemática em tokens como números, operadores e parênteses de abertura e de\nfechamento. Essa etapa é executada pela função <code>tokenize</code>.</p>\n<p><strong>Avaliar</strong> é a etapa de simplificar uma expressão matemática em seu resultado.\nPor exemplo, <code>3 + 3 * 2</code> tem <code>9</code> como resultado. A função responsável por essa\netapa é <code>evaluate</code>.</p>\n<h2>O teste de \"unidade\"</h2>\n<p>Nesse projeto foi usado <a href=\"https://github.com/catchorg/Catch2\">Catch</a> para\nescrever os testes de unidade. Dentre eles, existe o arquivo <code>evaluate.test.cpp</code>,\nque contém o seguinte caso de teste:</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-built_in\">TEST_CASE</span>(<span class=\"hljs-string\">\"evaluate 0\"</span>, <span class=\"hljs-string\">\"[evaluate]\"</span>) {\n  <span class=\"hljs-type\">char</span>* data;\n  <span class=\"hljs-type\">char</span>* result;\n  t_list* list;\n\n  <span class=\"hljs-type\">char</span> expression[] = <span class=\"hljs-string\">\"3*(8+4)/2\"</span>;\n\n  list = <span class=\"hljs-built_in\">tokenize</span>(expression);\n\n  <span class=\"hljs-built_in\">evaluate</span>(list, &#x26;result);\n  <span class=\"hljs-built_in\">REQUIRE</span>(<span class=\"hljs-built_in\">string</span>(result) == <span class=\"hljs-string\">\"18.000000\"</span>);\n  <span class=\"hljs-comment\">// Tem mais código que que libera memória,</span>\n  <span class=\"hljs-comment\">// mas será omitido daqui pra frente.</span>\n}\n</code></pre>\n<p>Baseado no nome do arquivo e no conteúdo do caso de teste, qual é a unidade sob\nteste?</p>\n<p>Se sua repostas foi <code>evaluate</code>, você acertou. Na época que eu escrevi esse teste\npela primeira vez, minha intenção era que ele fosse um teste de unidade.</p>\n<p>Se você é experiente com testes, você percebeu que esse teste, na realidade, não\né um teste de unidade porque ele também depende do funcionamento correto da\nfunção <code>tokenize</code>. Um caso de teste que ilustra isso é o <code>\"3*3-6/2\"</code>, que\nresulta na <a href=\"https://github.com/yudi-azvd/c-calculator/issues/2\">falha do teste</a>.</p>\n<p>Fiquei um tempo considerável procurando a origem do erro na função <code>evaluate</code>.\nTalvez não seja surpresa para você que está lendo agora, mas\n<a href=\"https://github.com/yudi-azvd/c-calculator/issues/2#issuecomment-1039256295\">descobri depois</a>\nque o erro estava na verdade na função <code>tokenize</code>.</p>\n<h2>Correção do teste</h2>\n<p>O ideal é que o sucesso do caso de teste dependa apenas da função sob teste,\nnesse contexto, <code>evaluate</code>. Vamos lembrar que essa função precisa de uma lista\nem que cada elemento seja um token para avaliar o resultado da expressão que ela\nrepresenta.</p>\n<p>Para corrigir o teste, precisamos de alguma rotina auxiliar, mais simples que\n<code>tokenize</code>, que transforme uma expressão do tipo <code>\"3*3-6/2\"</code> em uma lista de\ntokens. E precisamos fazer isso sem usar a função <code>tokenize</code> porque ela faz parte\nda lógica principal da calculadora e deve ser testada em outro lugar.</p>\n<p>A forma que eu escolhi para fazer isso foi assim:</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-function\">t_list* <span class=\"hljs-title\">create_char_list_from</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* str)</span> </span>{\n  t_list* l = <span class=\"hljs-built_in\">create_list</span>(<span class=\"hljs-string\">\"char*\"</span>);\n\n  <span class=\"hljs-type\">char</span>* delimeters = <span class=\"hljs-string\">\" \\t\\n\"</span>;\n  <span class=\"hljs-type\">char</span>* last_token_found = <span class=\"hljs-built_in\">strtok</span>(str, delimeters);\n  <span class=\"hljs-comment\">// strtok modifica o seu primeiro parâmetro, use com cuidado!</span>\n  <span class=\"hljs-keyword\">while</span> (last_token_found != <span class=\"hljs-literal\">NULL</span>) {\n    <span class=\"hljs-type\">char</span>* s = <span class=\"hljs-built_in\">calloc</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">strlen</span>(last_token_found)+<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-built_in\">strcpy</span>(s, last_token_found);\n    <span class=\"hljs-built_in\">insert_tail</span>(l, s);\n    last_token_found = <span class=\"hljs-built_in\">strtok</span>(<span class=\"hljs-literal\">NULL</span>, delimeters);\n  }\n\n  <span class=\"hljs-keyword\">return</span> l;\n}\n</code></pre>\n<p>(A criação dessa função foi uma adaptação desse\n<a href=\"https://www.cplusplus.com/reference/cstring/strtok/\">exemplo</a>)</p>\n<p><code>create_char_list_from</code> cria uma lista encadeada de strings a partir de uma string,\nseparando os elementos por espaço em branco.\nNa terra do C, a gente tem que implementar algumas rotinas por conta própria mesmo.\nSe você usa outra linguagem mais moderna, não se preocupe com essa parte.\nApenas considere que <code>create_char_list_from</code> funciona de forma semelhante ao\nmétodo <code>split</code> do\n<a href=\"https://docs.python.org/3.3/library/stdtypes.html?highlight=split#str.split\">Python</a>\nou do\n<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-\">Java</a>.</p>\n<p>Exemplo de string de entrada: <code>\"3 * ( 8 + 4 ) / 2\"</code>. Essa entrada deve causar o\nretorno de uma lista encadeada com os elementos:</p>\n<p><code>3, *, (, 8, +, 4, ), /, 2</code></p>\n<p>Reescrevendo o caso de teste com a função <code>create_char_list_from</code> temos o seguinte:</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-built_in\">TEST_CASE</span>(<span class=\"hljs-string\">\"evaluate 0\"</span>, <span class=\"hljs-string\">\"[evaluate]\"</span>) {\n  <span class=\"hljs-type\">char</span>* data;\n  <span class=\"hljs-type\">char</span>* result;\n  t_list* list;\n\n  <span class=\"hljs-type\">char</span> expression[] = <span class=\"hljs-string\">\" 3 * ( 8 + 4 ) / 2\"</span>;\n  list = <span class=\"hljs-built_in\">create_char_list_from</span>(expression);\n\n  <span class=\"hljs-built_in\">evaluate</span>(list, &#x26;result);\n  <span class=\"hljs-built_in\">REQUIRE</span>(<span class=\"hljs-built_in\">string</span>(result) == <span class=\"hljs-string\">\"18.000000\"</span>);\n}\n</code></pre>\n<p>Antes, o sucesso do caso de teste dependia de duas etapas importantes e\nrelativamente complexas do ciclo da calculadora. Depois da correção, ele depende\nde apenas uma etapa da calculadora (a unidade sob teste) e de uma função auxiliar\nrelativamente simples que <em>não</em> faz parte da lógica principal da calculadora.</p>\n<h2>Conclusão</h2>\n<p>Não deixe a preguiça atingir você, pense um pouco sobre como você está escrevendo\nseus testes. Independemente se a unidade sob teste for uma classe, método ou\nfunção, o seu sucesso deve depender apenas dessa unidade.</p>\n<h3>Observações tangentes</h3>\n<ul>\n<li>Escrevendo esse post eu percebi que havia um bug em <code>create_char_list_from</code>.\nPor isso, vale reforçar que é importante testar as funções auxiliares que você\nescreve.</li>\n<li>Não use o código do repositório para entender as funções. No momento em que você\nacessar o link, o código provavelmente já mudou. O que está escrito neste post\ndeve ser o suficiente para entender o que estou tentado dizer.</li>\n<li>Não use os nomes dos testes como eu fiz. Eu era jovem e preguiçoso. Dê nomes\ndescritivos para os seus casos de teste. Assista esse\n<a href=\"https://youtu.be/MWsk1h8pv2Q?t=892\">trecho</a> para ter uma ideia de como escolher\nbons nomes.</li>\n<li>A função <code>evaluate</code> ainda não é totalmente isolável porque ela utiliza internamente\na função <code>to_postfix</code> que converte uma expressão na forma\n<a href=\"https://en.wikipedia.org/wiki/Infix_notation\">infixa</a> para\n<a href=\"https://en.wikipedia.org/wiki/Reverse_Polish_notation\">pós-fixa</a>. Essa conversão\né um pré-requisito para avaliação de uma expressão e, por isso, talvez seja\ninteressante separar essas duas funções e testá-las isoladamente.</li>\n</ul>","title":"Corrigindo testes de unidade","tags":["testes"],"excerpt":"Um aspecto importante para escrever um bom teste de\nunidade é ter em mente qual é a unidade sob teste\n","description":"Ao implementar essa calculadora, eu me propus a fazer testes unitários para\naprender boas práticas de programação e ter mais segurança do funcionamento\ncorreto das funções desenvolvidas. Mal sabia eu que apenas escrever asserções\nsobre as expectativas de resultados corretos não era o suficiente para escrever\nbons testes de unidade. Um aspecto importante para escrever um bom teste de\nunidade é ter em mente qual é a unidade sob teste. Dessa parte eu sabia, mas\nnão estava convicto, o que acabou resultando depois em dor de cabeça\ndesnecessária.\n"}},"__N_SSG":true}