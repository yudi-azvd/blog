{"pageProps":{"post":{"id":"automacao-com-bash-parte-1","content":"<!-- ## O que é automatizar um processo?\n\n- É a primeira coisa que um programador pensa depois de fazer a mesma coisa\n  mais de uma vez.\n\nNinguém quer ficar repetindo os mesmos comandos terminal ou na IDE.\n\n## O que é automação?\n\n- É o resultado do trabalho de alguém preguiçoso.\n\n- É diminuir a presença de uma pessoa em determinado processo.\n\n## Benefícios\n\n- O mais óbvio é a economia de tempo porque você não precisa executar uma série\n  de passos manualmente.\n\n- Reduz a carga mental do programador. Ele precisa se preocupar com menos coisas,\n  fazer menos coisas por que parte delas já estão sendo feitas por um script.\n\n- ...\n\n- _Bônus_: em alguns casos, dá uma noção melhor de como montar um pipeline de\n  Entrega Contínua, o famoso CI, conceito fundamental na área de DevOps. -->\n\n<h2 id=\"ideia-geral-desta-série-de-posts\">Ideia geral desta série de posts</h2>\n<p>Nesta série de posts, vou apresentar alguns processos que eu automatizei durante\nalgumas disciplinas na universidade, a maioria deles em Bash (Bourne Again Shell).\nPode ser que a automação aconteça usando outras ferrametas como o Python\ne outros em ambientes como uma IDE ou uma pipeline de CI.</p>\n<p>A ideia é que você leia esses posts, aprenda uma ferramenta ou outra e se inspire\npara automatizar os seus próprios processos na sua vida de programação.</p>\n<p>Eu mesmo fui inspirado por uma aula da disciplina\n<a href=\"https://missing.csail.mit.edu/\">Missing Semester</a> do MIT.\nA aula de <a href=\"https://missing.csail.mit.edu/2020/data-wrangling/\">data wrangling</a>\nfoi onde eu formei a base do meu conhecimento (ainda fraca por falta de prática)\ndo programa <code>sed</code> e de <a href=\"https://en.wikipedia.org/wiki/Regular_expression\">regex</a>\n(regular expressions ou expressões regulares),\nque vão ser bastante usados nesta série. Se você estuda Ciências da Computação ou\nEngeharia de Software, vale à pena você dar uma olhada nessa disciplina.</p>\n<h2 id=\"tópicos-deste-post\">Tópicos deste post</h2>\n<p>Neste post vamos aprender alguns conceitos e comandos:</p>\n<ul>\n<li>operador pipe</li>\n<li><code>watch</code></li>\n<li><code>ps</code></li>\n<li><code>grep</code></li>\n</ul>\n<h2 id=\"o-que-você-precisa\">O que você precisa</h2>\n<ul>\n<li>Computador com ambiente Unix (Máquina virtual, dual boot com alguma distro Linux)<ul>\n<li>Se você está em Windows, você pode usar o <a href=\"https://docs.microsoft.com/en-us/windows/wsl/install\">WSL2</a>.</li>\n</ul>\n</li>\n<li>Terminal</li>\n<li>gcc (não é obrigatório)</li>\n</ul>\n<h2 id=\"um-pouco-de-prática-relógio-ao-vivo-de-terminal\">Um pouco de prática: relógio ao vivo de terminal</h2>\n<p>Vamos começar com uma situação muito simples: <strong>mostrar as horas no terminal a cada\nintervalo de tempo, como um relógio ao vivo</strong>. Em Linux, um que comando que mostra as\nhoras é o <code>date</code>. Se você usá-lo no terminal, você deve ver algo assim:</p>\n<pre><code>sex nov 26 18:40:39 -03 2021\n</code></pre>\n<p>Como queremos apenas as horas, podemos passar a opção <code>+&quot;%R:%s&quot;</code>. O resultado de\nexecutar <code>date +&quot;%R:%s&quot;</code> é:</p>\n<pre><code>18:40:55\n</code></pre>\n<p>Mas esse comando mostra as horas apenas uma vez. Teríamos que executar o comando\n<code>date</code> pelo menos uma vez por segundo para termos um relógio decente. Queremos algo\nmais automático. Para isso vamos usar o comando <code>watch</code>. <code>watch</code> executa um comando\nperiodicamente mostrando o resultado dele em tela cheia. Esse comando é muito\nútil quando queremos observar alguma coisa que muda com o tempo sem ter que ficar\ndigitando um comando no terminal toda ver que queremos ver um resultado.</p>\n<p>Você pode aprender mais sobre comandos no <code>manpages</code> do Linux. Se você rodar\n<code>man watch</code> você verá algo assim no terminal:</p>\n<pre><code>WATCH(1)                        User Commands                       WATCH(1)\n\nNAME\n       watch - execute a program periodically, showing output fullscreen\n\nSYNOPSIS\n       watch [options] command\n\nDESCRIPTION\n       watch  runs command repeatedly, displaying its output and errors (the\n       first screenfull).  This allows  you  to  watch  the  program  output\n       change  over  time.   By  default, command is run every 2 seconds and\n       watch will run until interrupted.\n</code></pre>\n<p>No terminal, você pode rolar a página para baixo com as setas do teclado ou com\na barra de rolagem do mouse. Toda vez que você tiver dúvida sobre o funcionamento\nde algum comando ou suas flags e opções, <del>pesquise primeiro no Stackoverflow</del>\nconsulte as páginas do manual para esse comando.</p>\n<p>Executando <code>watch date +%R</code> no terminal deve resultar nas horas sendo impressas\na cada 2 segundos, com um cabeçalho com parâmetros adicionais sobre o comando. Não\né bem o que a gente quer, mas estamos quase lá. Você pode interromper a execução\nde <code>watch</code> com <kbd>Ctrl</kbd> + <kbd>C</kbd></p>\n<p>Olhando no manual de <code>watch</code>,\npercebemos que existe uma flag <code>-n</code> para especificar o intervalo de tempo em\nsegundos. O intervalo padrão, como pode-se perceber é de 2 segundos. Se queremos\num relógio ao vivo, podemos diminuir o intervalo para 1 segundo ou um intervalo\nmenor que isso.</p>\n<pre><code>watch -n 0.5 date +%R\n</code></pre>\n<p>Note que a flag <code>-n</code> é para o comando <code>watch</code> e não para o comando <code>date</code>.</p>\n<p><strong>Exercício para o leitor:</strong> consultando as páginas do manual, descubra como fazer\no comando <code>watch</code> não mostrar o cabeçalho com informações adicionais, ou seja,\nque mostre apenas o resultado do comando <code>date</code>. <em>Dica:</em> procure por título ou\ntitle.</p>\n<h2 id=\"um-pouco-mais-complicado-árvore-de-processos\">Um pouco mais complicado: árvore de processos</h2>\n<p>Vamos usar esses conhecimentos em um cenário um pouco mais complicado:\n<strong>observar a árvore de processos de um programa</strong>.</p>\n<p>Para isso, vamos executar um programa feito em C que simplesmente cria vários\nprocessos filhos e morre depois de alguns segundos:</p>\n<pre><code class=\"language-c\">// procs.c\n#include &lt;stdio.h&gt;\n#include &lt;sys/types.h&gt; // pid_t\n#include &lt;unistd.h&gt; // fork, sleep\n\nint main() {\n  int i;\n  pid_t pid;\n\n  for (i = 0; i &lt; 3; i++) {\n    sleep(1);\n    pid = fork();\n\n    if (pid &gt; 0) {\n      sleep(2);\n      fork();\n    }\n  }\n\n  return 0;\n}\n</code></pre>\n<p>Compile com <code>gcc procs.c</code> e execute com <code>./a.out</code>.</p>\n<p>Você pode escolher outro programa para observar. Navegadores web (Chrome, Brave\nBrowser, Edge) são ótimos exemplos.</p>\n<p>Vamos usar novos comandos para isso:</p>\n<ul>\n<li><code>ps</code>: mostra um snapshot dos processos atuais.</li>\n<li><code>grep</code>: imprime as linhas que contém determinada string.</li>\n</ul>\n<p>Consulte os manuais desses comando para saber mais (eu só traduzi essas definições\nde lá). Tome um tempo pra explorar o comando <code>ps</code> com diferentes flags e opções.\nLeia a seção <code>EXAMPLES</code> do manual do <code>ps</code>. Depois disso, tente filtrar o resultado\ndo comando <code>ps</code> com o <code>grep</code> para obter os processos de determinado programa.</p>\n<p>Se você conseguiu fazer tudo isso, fica fácil mostrar a árvore de processos de um\nprograma a sua escolha. Caso contrário, continue lendo.</p>\n<p>Para usar esses comandos, vamos usar o\n<a href=\"https://en.wikipedia.org/wiki/Pipeline_(Unix)\">operador pipe</a> em shell. O pipe\nredireciona a saída padrão de um comando (ou programa) para a entrada padrão de\noutro comando (ou programa). A partir de agora, use duas janelas de terminal: uma\npara executar os comandos de shell e a outra para executar o programa em C.</p>\n<p>Na primeira janela, execute o programa em C com</p>\n<pre><code>./a.out\n</code></pre>\n<p>Logo em seguida, na segunda janela de terminal, execute o seguinte:</p>\n<pre><code class=\"language-sh\">ps axjf | grep &quot;a.out&quot;\n</code></pre>\n<p>(Ao invés de observar o programa <code>a.out</code>, você pode observar algum navegador.\nBasta substituir <code>a.out</code> por <code>google-chrome</code> ou <code>brave-browser</code>).</p>\n<p>Se você executou os comandos anteriores suficientemente rápido, você deve ver\numa árvore de processos em certo instante da execução do programa <code>a.out</code>. Se\nvocê não conseguiu ser rápido o suficiente, você pode aumentar o tempo nas\nchamadas de função <code>sleep</code> ou, melhor ainda, usar o comando <code>watch</code>.</p>\n<pre><code class=\"language-sh\">watch -n 0.1 &quot;ps axjf | grep &#39;a.out&#39;&quot;\n</code></pre>\n<blockquote>\n<p>Note os diferentes usos de aspas simples e aspas duplas nos comandos daqui\npra frente.</p>\n</blockquote>\n<p>As opções pra <code>ps</code> vão listar todos os processos do computador e mostrar a relação\nentre alguns deles através de uma árvore. Usando o resultado do <code>ps</code>, <code>grep</code>\nimprime todas as linhas com a string <code>a.out</code> presente.</p>\n<p><strong>Exercício para o leitor:</strong> você pode notar que mesmo depois que o programa\n<code>a.out</code> termina sua execução, o\ncomando <code>watch</code> continua mostrando alguns resultados de processos como <code>watch</code> e\no próprio <code>grep</code>. Pesquise na internet ou nas páginas do manual como podemos\nmandar o <code>grep</code> <em>não</em> imprimir linhas com certas strings, de maneira que apareça\napenas a linhas dos processos filhos do <code>a.out</code>.</p>\n<p>Para atingir o objetivo do parágrafo anterior, podemos usar a flag <code>-v</code> do <code>grep</code>:</p>\n<pre><code class=\"language-sh\">watch -n 0.1 &quot;ps axjf | grep &#39;a.out&#39; | grep -v &#39;watch&#39;&quot;\n</code></pre>\n<p>Se você executar assim, ainda sobra um processo que não pertence à arvore de\nprocessos de <code>a.out</code>. Podemos removê-la com outro filtro para <code>grep</code></p>\n<pre><code class=\"language-sh\">watch -n 0.1 &quot;ps axjf | grep &#39;a.out&#39; | grep -v &#39;watch&#39; | grep -v &#39;grep&#39;&quot;\n</code></pre>\n<p>Mas podemos remover essa última parte de outra maneira:</p>\n<pre><code class=\"language-sh\">watch -n 0.1 &quot;ps axjf | grep &#39;a.out&#39; | grep -v -E &#39;watch|grep&#39;&quot;\n</code></pre>\n<p>Sem entrar em muitos detalhes, a flag <code>-E</code> habilita regex para o <code>grep</code>. No\ncontexto de regex, o operador <code>|</code> funciona como um operador lógico OU. Então,\npode-se ler <code>grep -v -E &#39;watch|grep&#39;</code> como &quot;não imprima as linhas que contêm\nwatch OU grep&quot;.</p>\n<p>E finalmente, o que resta na tela é a árvore de processos do programa <code>a.out</code>.</p>\n","title":"Automação com Bash, parte 1","excerpt":"O que é automação?","date":"2021-11-20","tags":["automação","bash","série-automação"]}},"__N_SSG":true}