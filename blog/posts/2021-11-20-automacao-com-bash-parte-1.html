<!DOCTYPE html><html lang="pt"><head><meta charSet="utf-8"/><meta name="description" content="Blog Yudi Yamane"/><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title> Automação com Bash, parte 1 </title><meta name="description" content="Básico de watch, ps e grep"/><meta name="next-head-count" content="4"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-208998328ec77b24.js" defer=""></script><script src="/_next/static/chunks/pages/_app-213fe302238fe535.js" defer=""></script><script src="/_next/static/chunks/pages/blog/posts/%5Bid%5D-b446c2d8d749c51c.js" defer=""></script><script src="/_next/static/ltNATlavMI6kMfj8c2dNQ/_buildManifest.js" defer=""></script><script src="/_next/static/ltNATlavMI6kMfj8c2dNQ/_ssgManifest.js" defer=""></script><script src="/_next/static/ltNATlavMI6kMfj8c2dNQ/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.3">:root{font-size:16px;--color-fg-default:#c9d1d9;--color-fg-muted:#8b949e;--color-fg-subtle:#484f58;--color-canvas-default:#0d1117;--color-canvas-subtle:#161b22;--color-border-default:#30363d;--color-border-muted:#21262d;--color-neutral-muted:rgba(110,118,129,0.4);--color-accent-fg:#58a6ff;--color-accent-emphasis:#1f6feb;--color-danger-fg:#f85149;}/*!sc*/
*{margin:0;padding:0;box-sizing:border-box;outline:0;}/*!sc*/
html{overflow-y:overlay;}/*!sc*/
body{background:var(--color-canvas-default);color:var(--color-fg-default);-webkit-font-smoothing:antialiased;}/*!sc*/
body,input,button{font-family:Roboto,sans-serif;font-size:16px;}/*!sc*/
h1,h2,h3,h4,h5,h6,strong{font-weight:bold;}/*!sc*/
h1{font-size:2.25rem;}/*!sc*/
h2{font-size:1.5rem;}/*!sc*/
h3{font-size:1rem;}/*!sc*/
button{cursor:pointer;}/*!sc*/
a{color:var(--color-accent-fg);-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
a:hover{-webkit-text-decoration:underline;text-decoration:underline;}/*!sc*/
data-styled.g1[id="sc-global-jfWIJc1"]{content:"sc-global-jfWIJc1,"}/*!sc*/
.gmBWFr{height:100vh;width:100vw;max-width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}/*!sc*/
data-styled.g9[id="sc-iCfMLu"]{content:"gmBWFr,"}/*!sc*/
.hNiPLv{margin:8% auto;width:90%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;line-height:1.5;}/*!sc*/
@media (min-width:650px){.hNiPLv{max-width:calc(800px - (30px * 2));}}/*!sc*/
.hNiPLv h1{margin-bottom:4px;}/*!sc*/
.hNiPLv h2,.hNiPLv h3{margin-bottom:16px;margin-top:8px;}/*!sc*/
.hNiPLv p{font-size:1em;margin-bottom:16px;}/*!sc*/
.hNiPLv li > p{margin-top:16px;}/*!sc*/
.hNiPLv li + li{margin-top:0.25em;}/*!sc*/
.hNiPLv code{background:var(--color-canvas-subtle);border-radius:6px;font-size:95%;padding:0px 0.4em;}/*!sc*/
.hNiPLv pre{background:var(--color-canvas-subtle);overflow:auto;padding:16px;border-radius:6px;font-size:12px;margin-top:0;margin-bottom:16px;}/*!sc*/
.hNiPLv kbd{display:inline-block;padding:3px 5px;font:11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas, Liberation Mono,monospace;line-height:10px;color:var(--color-fg-default);vertical-align:middle;background-color:var(--color-canvas-subtle);border:solid 1px var(--color-neutral-muted);border-bottom-color:var(--color-neutral-muted);border-radius:6px;box-shadow:inset 0 -1px 0 var(--color-neutral-muted);}/*!sc*/
.hNiPLv a{margin-top:16px;}/*!sc*/
.hNiPLv a:last-of-type{margin-bottom:32px;}/*!sc*/
.hNiPLv ul,.hNiPLv ol{margin-top:0;margin-bottom:16px;padding-left:2em;}/*!sc*/
.hNiPLv blockquote{margin:0;padding:0 1em;color:var(--color-fg-muted);border-left:0.25em solid var(--color-border-default);}/*!sc*/
.hNiPLv h1,.hNiPLv h2,.hNiPLv h3,.hNiPLv h4,.hNiPLv h5,.hNiPLv h6{margin-top:24px;margin-bottom:16px;line-height:1.25;}/*!sc*/
data-styled.g10[id="sc-furwcr"]{content:"hNiPLv,"}/*!sc*/
.bOHvJK{color:var(--color-fg-muted);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-bottom:16px;}/*!sc*/
.bOHvJK time,.bOHvJK small{font-size:1em;}/*!sc*/
.bOHvJK time{margin-right:4px;}/*!sc*/
data-styled.g11[id="sc-pVTFL"]{content:"bOHvJK,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-iCfMLu gmBWFr"><article class="sc-furwcr hNiPLv"><a href="/blog">← Voltar</a><h1> <!-- -->Automação com Bash, parte 1<!-- --> </h1><div class="sc-pVTFL bOHvJK"><time> <!-- -->2021-11-20<!-- --> </time><small> | <!-- -->automação, bash, série-automação</small></div><div><h2>Ideia geral desta série de posts</h2>
<p>Nesta série de posts, vou apresentar alguns processos que eu automatizei durante
algumas disciplinas na universidade, a maioria deles em Bash (Bourne Again Shell).
Pode ser que a automação aconteça usando outras ferrametas como o Python
e outros em ambientes como uma IDE ou uma pipeline de CI.</p>
<p>A ideia é que você leia esses posts, aprenda uma ferramenta ou outra e se inspire
para automatizar os seus próprios processos na sua vida de programação.</p>
<p>Eu mesmo fui inspirado por uma aula da disciplina
<a href="https://missing.csail.mit.edu/">Missing Semester</a> do MIT.
A aula de <a href="https://missing.csail.mit.edu/2020/data-wrangling/">data wrangling</a>
foi onde eu formei a base do meu conhecimento (ainda fraca por falta de prática)
do programa <code>sed</code> e de <a href="https://en.wikipedia.org/wiki/Regular_expression">regex</a>
(regular expressions ou expressões regulares),
que vão ser bastante usados nesta série. Se você estuda Ciências da Computação ou
Engeharia de Software, vale à pena você dar uma olhada nessa disciplina.</p>
<h2>Tópicos deste post</h2>
<p>Neste post vamos aprender alguns conceitos e comandos:</p>
<ul>
<li><code>watch</code></li>
<li>operador pipe</li>
<li><code>ps</code></li>
<li><code>grep</code></li>
</ul>
<h2>O que você precisa</h2>
<ul>
<li>Computador com ambiente Unix (Máquina virtual, dual boot com alguma distro Linux)
<ul>
<li>Se você está em Windows, você pode usar o <a href="https://docs.microsoft.com/en-us/windows/wsl/install">WSL2</a>.</li>
</ul>
</li>
<li>Terminal</li>
<li>gcc (não é obrigatório)</li>
</ul>
<h2>Um pouco de prática: relógio ao vivo de terminal</h2>
<p>Vamos começar com uma situação muito simples: <strong>mostrar as horas no terminal a cada
intervalo de tempo, como um relógio ao vivo</strong>. Em Linux, um comando que mostra as
horas é o <code>date</code>. Se você usá-lo no terminal, você deve ver algo assim:</p>
<pre><code>sex nov 26 18:40:39 -03 2021
</code></pre>
<p>Como queremos apenas as horas, podemos passar a opção <code>+"%R:%s"</code>. O resultado de
executar <code>date +"%R:%s"</code> é:</p>
<pre><code>18:40:55
</code></pre>
<p>Mas esse comando mostra as horas apenas uma vez. Teríamos que executar o comando
<code>date</code> pelo menos uma vez por segundo para termos um relógio decente. Queremos algo
mais automático. Para isso vamos usar o comando <code>watch</code>. <code>watch</code> executa um comando
periodicamente mostrando o resultado dele em tela cheia. Esse comando é muito
útil quando queremos observar alguma coisa que muda com o tempo sem ter que ficar
digitando um comando no terminal toda ver que queremos ver um resultado.</p>
<p>Você pode aprender mais sobre comandos no <code>manpages</code> do Linux. Se você rodar
<code>man watch</code> você verá algo assim no terminal:</p>
<pre><code>WATCH(1)                        User Commands                       WATCH(1)

NAME
       watch - execute a program periodically, showing output fullscreen

SYNOPSIS
       watch [options] command

DESCRIPTION
       watch  runs command repeatedly, displaying its output and errors (the
       first screenfull).  This allows  you  to  watch  the  program  output
       change  over  time.   By  default, command is run every 2 seconds and
       watch will run until interrupted.
</code></pre>
<p>No terminal, você pode rolar a página para baixo com as setas do teclado ou com
a barra de rolagem do mouse. Toda vez que você tiver dúvida sobre o funcionamento
de algum comando ou suas flags e opções, ~~pesquise primeiro no Stackoverflow~~
consulte as páginas do manual para esse comando.</p>
<p>Executando <code>watch date +%R</code> no terminal deve resultar nas horas sendo impressas
a cada 2 segundos, com um cabeçalho com parâmetros adicionais sobre o comando. Não
é bem o que a gente quer, mas estamos quase lá. Você pode interromper a execução
de <code>watch</code> com Ctrl + C.</p>
<p>Olhando no manual de <code>watch</code>,
percebemos que existe uma flag <code>-n</code> para especificar o intervalo de tempo em
segundos. O intervalo padrão, como pode-se perceber é de 2 segundos. Se queremos
um relógio ao vivo, podemos diminuir o intervalo para 1 segundo ou um intervalo
menor que isso.</p>
<pre><code>watch -n 0.5 date +%R
</code></pre>
<p>Note que a flag <code>-n</code> é para o comando <code>watch</code> e não para o comando <code>date</code>.</p>
<p><strong>Exercício para o leitor:</strong> consultando as páginas do manual, descubra como fazer
o comando <code>watch</code> não mostrar o cabeçalho com informações adicionais, ou seja,
que mostre apenas o resultado do comando <code>date</code>. <em>Dica:</em> procure por título ou
title.</p>
<h2>Um pouco mais complicado: árvore de processos</h2>
<p>Vamos usar esses conhecimentos em um cenário um pouco mais complicado:
<strong>observar a árvore de processos de um programa</strong>.</p>
<p>Para isso, vamos executar um programa feito em C que simplesmente cria vários
processos filhos e morre depois de alguns segundos:</p>
<pre><code>// procs.c
#include &#x3C;stdio.h>
#include &#x3C;sys/types.h> // pid_t
#include &#x3C;unistd.h> // fork, sleep

int main() {
  int i;
  pid_t pid;

  for (i = 0; i &#x3C; 3; i++) {
    sleep(1);
    pid = fork();

    if (pid > 0) {
      sleep(2);
      fork();
    }
  }

  return 0;
}
</code></pre>
<p>Compile com <code>gcc procs.c</code> e execute com <code>./a.out</code>.</p>
<p>Você pode escolher outro programa para observar. Navegadores web (Chrome, Brave
Browser, Edge) são ótimos exemplos.</p>
<p>Vamos usar novos comandos para isso:</p>
<ul>
<li><code>ps</code>: mostra um snapshot dos processos atuais.</li>
<li><code>grep</code>: imprime as linhas que contém determinada string.</li>
</ul>
<p>Consulte os manuais desses comando para saber mais (eu só traduzi essas definições
de lá). Tome um tempo pra explorar o comando <code>ps</code> com diferentes flags e opções.
Leia a seção <code>EXAMPLES</code> do manual do <code>ps</code>. Depois disso, tente filtrar o resultado
do comando <code>ps</code> com o <code>grep</code> para obter os processos de determinado programa.</p>
<p>Se você conseguiu fazer tudo isso, fica fácil mostrar a árvore de processos de um
programa a sua escolha. Caso contrário, continue lendo.</p>
<p>Para usar esses comandos, vamos usar o
<a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">operador pipe</a> em shell. O pipe
redireciona a saída padrão de um comando (ou programa) para a entrada padrão de
outro comando (ou programa). A partir de agora, use duas janelas de terminal: uma
para executar os comandos de shell e a outra para executar o programa em C.</p>
<p>Na primeira janela, execute o programa em C com</p>
<pre><code>./a.out
</code></pre>
<p>Logo em seguida, na segunda janela de terminal, execute o seguinte:</p>
<pre><code>ps axjf | grep "a.out"
</code></pre>
<p>(Ao invés de observar o programa <code>a.out</code>, você pode observar algum navegador.
Basta substituir <code>a.out</code> por <code>google-chrome</code> ou <code>brave-browser</code>).</p>
<p>Se você executou os comandos anteriores suficientemente rápido, você deve ver
uma árvore de processos em certo instante da execução do programa <code>a.out</code>. Se
você não conseguiu ser rápido o suficiente, você pode aumentar o tempo nas
chamadas de função <code>sleep</code> ou, melhor ainda, usar o comando <code>watch</code>.</p>
<pre><code>watch -n 0.1 "ps axjf | grep 'a.out'"
</code></pre>
<blockquote>
<p>Note os diferentes usos de aspas simples e aspas duplas nos comandos daqui
pra frente.</p>
</blockquote>
<p>As opções pra <code>ps</code> vão listar todos os processos do computador e mostrar a relação
entre alguns deles através de uma árvore. Usando o resultado do <code>ps</code>, <code>grep</code>
imprime todas as linhas com a string <code>a.out</code> presente.</p>
<p><strong>Exercício para o leitor:</strong> você pode notar que mesmo depois que o programa
<code>a.out</code> termina sua execução, o
comando <code>watch</code> continua mostrando alguns resultados de processos como <code>watch</code> e
o próprio <code>grep</code>. Pesquise na internet ou nas páginas do manual como podemos
mandar o <code>grep</code> <em>não</em> imprimir linhas com certas strings, de maneira que apareça
apenas a linhas dos processos filhos do <code>a.out</code>.</p>
<p>Para atingir o objetivo do parágrafo anterior, podemos usar a flag <code>-v</code> do <code>grep</code>:</p>
<pre><code>watch -n 0.1 "ps axjf | grep 'a.out' | grep -v 'watch'"
</code></pre>
<p>Se você executar assim, ainda sobra um processo que não pertence à arvore de
processos de <code>a.out</code>. Podemos removê-la com outro filtro para <code>grep</code></p>
<pre><code>watch -n 0.1 "ps axjf | grep 'a.out' | grep -v 'watch' | grep -v 'grep'"
</code></pre>
<p>Mas podemos remover essa última parte de outra maneira:</p>
<pre><code>watch -n 0.1 "ps axjf | grep 'a.out' | grep -v -E 'watch|grep'"
</code></pre>
<p>Sem entrar em muitos detalhes, a flag <code>-E</code> habilita regex para o <code>grep</code>. No
contexto de regex, o operador <code>|</code> funciona como um operador lógico OU. Então,
pode-se ler <code>grep -v -E 'watch|grep'</code> como "não imprima as linhas que contêm
watch OU grep".</p>
<p>E finalmente, o que resta na tela é a árvore de processos do programa <code>a.out</code>.</p>
</div><a href="/blog">← Voltar</a></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"2021-11-20-automacao-com-bash-parte-1","title":"Automação com Bash, parte 1","excerpt":"Básico de watch, ps e grep","date":"2021-11-20","tags":["automação","bash","série-automação"],"content":"\u003ch2\u003eIdeia geral desta série de posts\u003c/h2\u003e\n\u003cp\u003eNesta série de posts, vou apresentar alguns processos que eu automatizei durante\nalgumas disciplinas na universidade, a maioria deles em Bash (Bourne Again Shell).\nPode ser que a automação aconteça usando outras ferrametas como o Python\ne outros em ambientes como uma IDE ou uma pipeline de CI.\u003c/p\u003e\n\u003cp\u003eA ideia é que você leia esses posts, aprenda uma ferramenta ou outra e se inspire\npara automatizar os seus próprios processos na sua vida de programação.\u003c/p\u003e\n\u003cp\u003eEu mesmo fui inspirado por uma aula da disciplina\n\u003ca href=\"https://missing.csail.mit.edu/\"\u003eMissing Semester\u003c/a\u003e do MIT.\nA aula de \u003ca href=\"https://missing.csail.mit.edu/2020/data-wrangling/\"\u003edata wrangling\u003c/a\u003e\nfoi onde eu formei a base do meu conhecimento (ainda fraca por falta de prática)\ndo programa \u003ccode\u003esed\u003c/code\u003e e de \u003ca href=\"https://en.wikipedia.org/wiki/Regular_expression\"\u003eregex\u003c/a\u003e\n(regular expressions ou expressões regulares),\nque vão ser bastante usados nesta série. Se você estuda Ciências da Computação ou\nEngeharia de Software, vale à pena você dar uma olhada nessa disciplina.\u003c/p\u003e\n\u003ch2\u003eTópicos deste post\u003c/h2\u003e\n\u003cp\u003eNeste post vamos aprender alguns conceitos e comandos:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ewatch\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eoperador pipe\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eps\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egrep\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eO que você precisa\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eComputador com ambiente Unix (Máquina virtual, dual boot com alguma distro Linux)\n\u003cul\u003e\n\u003cli\u003eSe você está em Windows, você pode usar o \u003ca href=\"https://docs.microsoft.com/en-us/windows/wsl/install\"\u003eWSL2\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eTerminal\u003c/li\u003e\n\u003cli\u003egcc (não é obrigatório)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eUm pouco de prática: relógio ao vivo de terminal\u003c/h2\u003e\n\u003cp\u003eVamos começar com uma situação muito simples: \u003cstrong\u003emostrar as horas no terminal a cada\nintervalo de tempo, como um relógio ao vivo\u003c/strong\u003e. Em Linux, um comando que mostra as\nhoras é o \u003ccode\u003edate\u003c/code\u003e. Se você usá-lo no terminal, você deve ver algo assim:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esex nov 26 18:40:39 -03 2021\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eComo queremos apenas as horas, podemos passar a opção \u003ccode\u003e+\"%R:%s\"\u003c/code\u003e. O resultado de\nexecutar \u003ccode\u003edate +\"%R:%s\"\u003c/code\u003e é:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e18:40:55\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMas esse comando mostra as horas apenas uma vez. Teríamos que executar o comando\n\u003ccode\u003edate\u003c/code\u003e pelo menos uma vez por segundo para termos um relógio decente. Queremos algo\nmais automático. Para isso vamos usar o comando \u003ccode\u003ewatch\u003c/code\u003e. \u003ccode\u003ewatch\u003c/code\u003e executa um comando\nperiodicamente mostrando o resultado dele em tela cheia. Esse comando é muito\nútil quando queremos observar alguma coisa que muda com o tempo sem ter que ficar\ndigitando um comando no terminal toda ver que queremos ver um resultado.\u003c/p\u003e\n\u003cp\u003eVocê pode aprender mais sobre comandos no \u003ccode\u003emanpages\u003c/code\u003e do Linux. Se você rodar\n\u003ccode\u003eman watch\u003c/code\u003e você verá algo assim no terminal:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eWATCH(1)                        User Commands                       WATCH(1)\n\nNAME\n       watch - execute a program periodically, showing output fullscreen\n\nSYNOPSIS\n       watch [options] command\n\nDESCRIPTION\n       watch  runs command repeatedly, displaying its output and errors (the\n       first screenfull).  This allows  you  to  watch  the  program  output\n       change  over  time.   By  default, command is run every 2 seconds and\n       watch will run until interrupted.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNo terminal, você pode rolar a página para baixo com as setas do teclado ou com\na barra de rolagem do mouse. Toda vez que você tiver dúvida sobre o funcionamento\nde algum comando ou suas flags e opções, ~~pesquise primeiro no Stackoverflow~~\nconsulte as páginas do manual para esse comando.\u003c/p\u003e\n\u003cp\u003eExecutando \u003ccode\u003ewatch date +%R\u003c/code\u003e no terminal deve resultar nas horas sendo impressas\na cada 2 segundos, com um cabeçalho com parâmetros adicionais sobre o comando. Não\né bem o que a gente quer, mas estamos quase lá. Você pode interromper a execução\nde \u003ccode\u003ewatch\u003c/code\u003e com Ctrl + C.\u003c/p\u003e\n\u003cp\u003eOlhando no manual de \u003ccode\u003ewatch\u003c/code\u003e,\npercebemos que existe uma flag \u003ccode\u003e-n\u003c/code\u003e para especificar o intervalo de tempo em\nsegundos. O intervalo padrão, como pode-se perceber é de 2 segundos. Se queremos\num relógio ao vivo, podemos diminuir o intervalo para 1 segundo ou um intervalo\nmenor que isso.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewatch -n 0.5 date +%R\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote que a flag \u003ccode\u003e-n\u003c/code\u003e é para o comando \u003ccode\u003ewatch\u003c/code\u003e e não para o comando \u003ccode\u003edate\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExercício para o leitor:\u003c/strong\u003e consultando as páginas do manual, descubra como fazer\no comando \u003ccode\u003ewatch\u003c/code\u003e não mostrar o cabeçalho com informações adicionais, ou seja,\nque mostre apenas o resultado do comando \u003ccode\u003edate\u003c/code\u003e. \u003cem\u003eDica:\u003c/em\u003e procure por título ou\ntitle.\u003c/p\u003e\n\u003ch2\u003eUm pouco mais complicado: árvore de processos\u003c/h2\u003e\n\u003cp\u003eVamos usar esses conhecimentos em um cenário um pouco mais complicado:\n\u003cstrong\u003eobservar a árvore de processos de um programa\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003ePara isso, vamos executar um programa feito em C que simplesmente cria vários\nprocessos filhos e morre depois de alguns segundos:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// procs.c\n#include \u0026#x3C;stdio.h\u003e\n#include \u0026#x3C;sys/types.h\u003e // pid_t\n#include \u0026#x3C;unistd.h\u003e // fork, sleep\n\nint main() {\n  int i;\n  pid_t pid;\n\n  for (i = 0; i \u0026#x3C; 3; i++) {\n    sleep(1);\n    pid = fork();\n\n    if (pid \u003e 0) {\n      sleep(2);\n      fork();\n    }\n  }\n\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCompile com \u003ccode\u003egcc procs.c\u003c/code\u003e e execute com \u003ccode\u003e./a.out\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eVocê pode escolher outro programa para observar. Navegadores web (Chrome, Brave\nBrowser, Edge) são ótimos exemplos.\u003c/p\u003e\n\u003cp\u003eVamos usar novos comandos para isso:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eps\u003c/code\u003e: mostra um snapshot dos processos atuais.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egrep\u003c/code\u003e: imprime as linhas que contém determinada string.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eConsulte os manuais desses comando para saber mais (eu só traduzi essas definições\nde lá). Tome um tempo pra explorar o comando \u003ccode\u003eps\u003c/code\u003e com diferentes flags e opções.\nLeia a seção \u003ccode\u003eEXAMPLES\u003c/code\u003e do manual do \u003ccode\u003eps\u003c/code\u003e. Depois disso, tente filtrar o resultado\ndo comando \u003ccode\u003eps\u003c/code\u003e com o \u003ccode\u003egrep\u003c/code\u003e para obter os processos de determinado programa.\u003c/p\u003e\n\u003cp\u003eSe você conseguiu fazer tudo isso, fica fácil mostrar a árvore de processos de um\nprograma a sua escolha. Caso contrário, continue lendo.\u003c/p\u003e\n\u003cp\u003ePara usar esses comandos, vamos usar o\n\u003ca href=\"https://en.wikipedia.org/wiki/Pipeline_(Unix)\"\u003eoperador pipe\u003c/a\u003e em shell. O pipe\nredireciona a saída padrão de um comando (ou programa) para a entrada padrão de\noutro comando (ou programa). A partir de agora, use duas janelas de terminal: uma\npara executar os comandos de shell e a outra para executar o programa em C.\u003c/p\u003e\n\u003cp\u003eNa primeira janela, execute o programa em C com\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e./a.out\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLogo em seguida, na segunda janela de terminal, execute o seguinte:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eps axjf | grep \"a.out\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Ao invés de observar o programa \u003ccode\u003ea.out\u003c/code\u003e, você pode observar algum navegador.\nBasta substituir \u003ccode\u003ea.out\u003c/code\u003e por \u003ccode\u003egoogle-chrome\u003c/code\u003e ou \u003ccode\u003ebrave-browser\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eSe você executou os comandos anteriores suficientemente rápido, você deve ver\numa árvore de processos em certo instante da execução do programa \u003ccode\u003ea.out\u003c/code\u003e. Se\nvocê não conseguiu ser rápido o suficiente, você pode aumentar o tempo nas\nchamadas de função \u003ccode\u003esleep\u003c/code\u003e ou, melhor ainda, usar o comando \u003ccode\u003ewatch\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewatch -n 0.1 \"ps axjf | grep 'a.out'\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote os diferentes usos de aspas simples e aspas duplas nos comandos daqui\npra frente.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAs opções pra \u003ccode\u003eps\u003c/code\u003e vão listar todos os processos do computador e mostrar a relação\nentre alguns deles através de uma árvore. Usando o resultado do \u003ccode\u003eps\u003c/code\u003e, \u003ccode\u003egrep\u003c/code\u003e\nimprime todas as linhas com a string \u003ccode\u003ea.out\u003c/code\u003e presente.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExercício para o leitor:\u003c/strong\u003e você pode notar que mesmo depois que o programa\n\u003ccode\u003ea.out\u003c/code\u003e termina sua execução, o\ncomando \u003ccode\u003ewatch\u003c/code\u003e continua mostrando alguns resultados de processos como \u003ccode\u003ewatch\u003c/code\u003e e\no próprio \u003ccode\u003egrep\u003c/code\u003e. Pesquise na internet ou nas páginas do manual como podemos\nmandar o \u003ccode\u003egrep\u003c/code\u003e \u003cem\u003enão\u003c/em\u003e imprimir linhas com certas strings, de maneira que apareça\napenas a linhas dos processos filhos do \u003ccode\u003ea.out\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003ePara atingir o objetivo do parágrafo anterior, podemos usar a flag \u003ccode\u003e-v\u003c/code\u003e do \u003ccode\u003egrep\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewatch -n 0.1 \"ps axjf | grep 'a.out' | grep -v 'watch'\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSe você executar assim, ainda sobra um processo que não pertence à arvore de\nprocessos de \u003ccode\u003ea.out\u003c/code\u003e. Podemos removê-la com outro filtro para \u003ccode\u003egrep\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewatch -n 0.1 \"ps axjf | grep 'a.out' | grep -v 'watch' | grep -v 'grep'\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMas podemos remover essa última parte de outra maneira:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewatch -n 0.1 \"ps axjf | grep 'a.out' | grep -v -E 'watch|grep'\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSem entrar em muitos detalhes, a flag \u003ccode\u003e-E\u003c/code\u003e habilita regex para o \u003ccode\u003egrep\u003c/code\u003e. No\ncontexto de regex, o operador \u003ccode\u003e|\u003c/code\u003e funciona como um operador lógico OU. Então,\npode-se ler \u003ccode\u003egrep -v -E 'watch|grep'\u003c/code\u003e como \"não imprima as linhas que contêm\nwatch OU grep\".\u003c/p\u003e\n\u003cp\u003eE finalmente, o que resta na tela é a árvore de processos do programa \u003ccode\u003ea.out\u003c/code\u003e.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/blog/posts/[id]","query":{"id":"2021-11-20-automacao-com-bash-parte-1"},"buildId":"ltNATlavMI6kMfj8c2dNQ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>