<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title> Automação com Bash, parte 1 </title><meta name="next-head-count" content="3"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-208998328ec77b24.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2cb0343f92c0f109.js" defer=""></script><script src="/_next/static/chunks/pages/blog/posts/%5Bid%5D-913c2fc6e5718442.js" defer=""></script><script src="/_next/static/f59elqndpmj3zC08JeRq4/_buildManifest.js" defer=""></script><script src="/_next/static/f59elqndpmj3zC08JeRq4/_ssgManifest.js" defer=""></script><script src="/_next/static/f59elqndpmj3zC08JeRq4/_middlewareManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.3">:root{font-size:16px;--color-fg-default:#24292f;--color-fg-muted:#57606a;--color-fg-subtle:#6e7781;--color-canvas-default:#ffffff;--color-canvas-subtle:#f6f8fa;--color-border-default:#d0d7de;--color-border-muted:hsla(210,18%,87%,1);--color-neutral-muted:rgba(175,184,193,0.2);--color-accent-fg:#0969da;--color-accent-emphasis:#0969da;--color-danger-fg:#cf222e;}/*!sc*/
*{margin:0;padding:0;box-sizing:border-box;outline:0;}/*!sc*/
body{background:#fff;color:#222;-webkit-font-smoothing:antialiased;}/*!sc*/
body,input,button{font-family:Roboto,sans-serif;font-size:16px;}/*!sc*/
h1,h2,h3,h4,h5,h6,strong{font-weight:bold;}/*!sc*/
h1{font-size:2.25rem;}/*!sc*/
h2{font-size:1.5rem;}/*!sc*/
h3{font-size:1rem;}/*!sc*/
button{cursor:pointer;}/*!sc*/
a{color:#0070f3;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
a:hover{-webkit-text-decoration:underline;text-decoration:underline;}/*!sc*/
data-styled.g1[id="sc-global-ldAJPj1"]{content:"sc-global-ldAJPj1,"}/*!sc*/
.brrvpM{background:blue;}/*!sc*/
data-styled.g2[id="sc-bdvvtL"]{content:"brrvpM,"}/*!sc*/
.gfOEKo{height:100vh;width:100vw;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}/*!sc*/
data-styled.g7[id="sc-jRQBWg"]{content:"gfOEKo,"}/*!sc*/
.dGQCsQ{margin:8% auto;width:90%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}/*!sc*/
.dGQCsQ h1{font-weight:normal;margin-bottom:4px;}/*!sc*/
.dGQCsQ h2,.dGQCsQ h3{margin-bottom:16px;margin-top:8px;}/*!sc*/
.dGQCsQ p{font-size:1em;margin-bottom:16px;}/*!sc*/
.dGQCsQ li > p{margin-top:16px;}/*!sc*/
.dGQCsQ li + li{margin-top:0.25em;}/*!sc*/
.dGQCsQ code{background:#ccc;border-radius:4px;padding:0px 0.2em;}/*!sc*/
.dGQCsQ pre{background:#ccc;overflow:scroll;padding:8px;border-radius:4px;font-size:12px;margin-top:0;margin-bottom:16px;}/*!sc*/
.dGQCsQ kbd{display:inline-block;padding:3px 5px;font:11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas, Liberation Mono,monospace;line-height:10px;color:var(--color-fg-default);vertical-align:middle;background-color:var(--color-canvas-subtle);border:solid 1px var(--color-neutral-muted);border-bottom-color:var(--color-neutral-muted);border-radius:6px;box-shadow:inset 0 -1px 0 var(--color-neutral-muted);}/*!sc*/
.dGQCsQ a{margin-top:16px;}/*!sc*/
.dGQCsQ ul,.dGQCsQ ol{margin-top:0;margin-bottom:16px;padding-left:2em;}/*!sc*/
.dGQCsQ blockquote{margin:0;padding:0 1em;color:var(--color-fg-muted);border-left:0.25em solid var(--color-border-default);}/*!sc*/
.dGQCsQ h1,.dGQCsQ h2,.dGQCsQ h3,.dGQCsQ h4,.dGQCsQ h5,.dGQCsQ h6{margin-top:24px;margin-bottom:16px;line-height:1.25;}/*!sc*/
data-styled.g8[id="sc-gKclnd"]{content:"dGQCsQ,"}/*!sc*/
.ebGiVV{color:grey;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin-bottom:16px;}/*!sc*/
.ebGiVV time,.ebGiVV small{font-size:0.8em;}/*!sc*/
.ebGiVV time{margin-right:4px;}/*!sc*/
data-styled.g9[id="sc-iCfMLu"]{content:"ebGiVV,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-jRQBWg gfOEKo"><article class="sc-gKclnd dGQCsQ"><h1> <!-- -->Automação com Bash, parte 1<!-- --> </h1><div class="sc-iCfMLu ebGiVV"><time> <!-- -->2021-11-20<!-- --> </time><small> | <!-- -->automação, bash, série-automação</small></div><div><!-- ## O que é automatizar um processo?

- É a primeira coisa que um programador pensa depois de fazer a mesma coisa
  mais de uma vez.

Ninguém quer ficar repetindo os mesmos comandos terminal ou na IDE.

## O que é automação?

- É o resultado do trabalho de alguém preguiçoso.

- É diminuir a presença de uma pessoa em determinado processo.

## Benefícios

- O mais óbvio é a economia de tempo porque você não precisa executar uma série
  de passos manualmente.

- Reduz a carga mental do programador. Ele precisa se preocupar com menos coisas,
  fazer menos coisas por que parte delas já estão sendo feitas por um script.

- ...

- _Bônus_: em alguns casos, dá uma noção melhor de como montar um pipeline de
  Entrega Contínua, o famoso CI, conceito fundamental na área de DevOps. -->

<h2 id="ideia-geral-desta-série-de-posts">Ideia geral desta série de posts</h2>
<p>Nesta série de posts, vou apresentar alguns processos que eu automatizei durante
algumas disciplinas na universidade, a maioria deles em Bash (Bourne Again Shell).
Pode ser que a automação aconteça usando outras ferrametas como o Python
e outros em ambientes como uma IDE ou uma pipeline de CI.</p>
<p>A ideia é que você leia esses posts, aprenda uma ferramenta ou outra e se inspire
para automatizar os seus próprios processos na sua vida de programação.</p>
<p>Eu mesmo fui inspirado por uma aula da disciplina
<a href="https://missing.csail.mit.edu/">Missing Semester</a> do MIT.
A aula de <a href="https://missing.csail.mit.edu/2020/data-wrangling/">data wrangling</a>
foi onde eu formei a base do meu conhecimento (ainda fraca por falta de prática)
do programa <code>sed</code> e de <a href="https://en.wikipedia.org/wiki/Regular_expression">regex</a>
(regular expressions ou expressões regulares),
que vão ser bastante usados nesta série. Se você estuda Ciências da Computação ou
Engeharia de Software, vale à pena você dar uma olhada nessa disciplina.</p>
<h2 id="tópicos-deste-post">Tópicos deste post</h2>
<p>Neste post vamos aprender alguns conceitos e comandos:</p>
<ul>
<li>operador pipe</li>
<li><code>watch</code></li>
<li><code>ps</code></li>
<li><code>grep</code></li>
</ul>
<h2 id="o-que-você-precisa">O que você precisa</h2>
<ul>
<li>Computador com ambiente Unix (Máquina virtual, dual boot com alguma distro Linux)<ul>
<li>Se você está em Windows, você pode usar o <a href="https://docs.microsoft.com/en-us/windows/wsl/install">WSL2</a>.</li>
</ul>
</li>
<li>Terminal</li>
<li>gcc (não é obrigatório)</li>
</ul>
<h2 id="um-pouco-de-prática-relógio-ao-vivo-de-terminal">Um pouco de prática: relógio ao vivo de terminal</h2>
<p>Vamos começar com uma situação muito simples: <strong>mostrar as horas no terminal a cada
intervalo de tempo, como um relógio ao vivo</strong>. Em Linux, um que comando que mostra as
horas é o <code>date</code>. Se você usá-lo no terminal, você deve ver algo assim:</p>
<pre><code>sex nov 26 18:40:39 -03 2021
</code></pre>
<p>Como queremos apenas as horas, podemos passar a opção <code>+&quot;%R:%s&quot;</code>. O resultado de
executar <code>date +&quot;%R:%s&quot;</code> é:</p>
<pre><code>18:40:55
</code></pre>
<p>Mas esse comando mostra as horas apenas uma vez. Teríamos que executar o comando
<code>date</code> pelo menos uma vez por segundo para termos um relógio decente. Queremos algo
mais automático. Para isso vamos usar o comando <code>watch</code>. <code>watch</code> executa um comando
periodicamente mostrando o resultado dele em tela cheia. Esse comando é muito
útil quando queremos observar alguma coisa que muda com o tempo sem ter que ficar
digitando um comando no terminal toda ver que queremos ver um resultado.</p>
<p>Você pode aprender mais sobre comandos no <code>manpages</code> do Linux. Se você rodar
<code>man watch</code> você verá algo assim no terminal:</p>
<pre><code>WATCH(1)                        User Commands                       WATCH(1)

NAME
       watch - execute a program periodically, showing output fullscreen

SYNOPSIS
       watch [options] command

DESCRIPTION
       watch  runs command repeatedly, displaying its output and errors (the
       first screenfull).  This allows  you  to  watch  the  program  output
       change  over  time.   By  default, command is run every 2 seconds and
       watch will run until interrupted.
</code></pre>
<p>No terminal, você pode rolar a página para baixo com as setas do teclado ou com
a barra de rolagem do mouse. Toda vez que você tiver dúvida sobre o funcionamento
de algum comando ou suas flags e opções, <del>pesquise primeiro no Stackoverflow</del>
consulte as páginas do manual para esse comando.</p>
<p>Executando <code>watch date +%R</code> no terminal deve resultar nas horas sendo impressas
a cada 2 segundos, com um cabeçalho com parâmetros adicionais sobre o comando. Não
é bem o que a gente quer, mas estamos quase lá. Você pode interromper a execução
de <code>watch</code> com <kbd>Ctrl</kbd> + <kbd>C</kbd></p>
<p>Olhando no manual de <code>watch</code>,
percebemos que existe uma flag <code>-n</code> para especificar o intervalo de tempo em
segundos. O intervalo padrão, como pode-se perceber é de 2 segundos. Se queremos
um relógio ao vivo, podemos diminuir o intervalo para 1 segundo ou um intervalo
menor que isso.</p>
<pre><code>watch -n 0.5 date +%R
</code></pre>
<p>Note que a flag <code>-n</code> é para o comando <code>watch</code> e não para o comando <code>date</code>.</p>
<p><strong>Exercício para o leitor:</strong> consultando as páginas do manual, descubra como fazer
o comando <code>watch</code> não mostrar o cabeçalho com informações adicionais, ou seja,
que mostre apenas o resultado do comando <code>date</code>. <em>Dica:</em> procure por título ou
title.</p>
<h2 id="um-pouco-mais-complicado-árvore-de-processos">Um pouco mais complicado: árvore de processos</h2>
<p>Vamos usar esses conhecimentos em um cenário um pouco mais complicado:
<strong>observar a árvore de processos de um programa</strong>.</p>
<p>Para isso, vamos executar um programa feito em C que simplesmente cria vários
processos filhos e morre depois de alguns segundos:</p>
<pre><code class="language-c">// procs.c
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt; // pid_t
#include &lt;unistd.h&gt; // fork, sleep

int main() {
  int i;
  pid_t pid;

  for (i = 0; i &lt; 3; i++) {
    sleep(1);
    pid = fork();

    if (pid &gt; 0) {
      sleep(2);
      fork();
    }
  }

  return 0;
}
</code></pre>
<p>Compile com <code>gcc procs.c</code> e execute com <code>./a.out</code>.</p>
<p>Você pode escolher outro programa para observar. Navegadores web (Chrome, Brave
Browser, Edge) são ótimos exemplos.</p>
<p>Vamos usar novos comandos para isso:</p>
<ul>
<li><code>ps</code>: mostra um snapshot dos processos atuais.</li>
<li><code>grep</code>: imprime as linhas que contém determinada string.</li>
</ul>
<p>Consulte os manuais desses comando para saber mais (eu só traduzi essas definições
de lá). Tome um tempo pra explorar o comando <code>ps</code> com diferentes flags e opções.
Leia a seção <code>EXAMPLES</code> do manual do <code>ps</code>. Depois disso, tente filtrar o resultado
do comando <code>ps</code> com o <code>grep</code> para obter os processos de determinado programa.</p>
<p>Se você conseguiu fazer tudo isso, fica fácil mostrar a árvore de processos de um
programa a sua escolha. Caso contrário, continue lendo.</p>
<p>Para usar esses comandos, vamos usar o
<a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">operador pipe</a> em shell. O pipe
redireciona a saída padrão de um comando (ou programa) para a entrada padrão de
outro comando (ou programa). A partir de agora, use duas janelas de terminal: uma
para executar os comandos de shell e a outra para executar o programa em C.</p>
<p>Na primeira janela, execute o programa em C com</p>
<pre><code>./a.out
</code></pre>
<p>Logo em seguida, na segunda janela de terminal, execute o seguinte:</p>
<pre><code class="language-sh">ps axjf | grep &quot;a.out&quot;
</code></pre>
<p>(Ao invés de observar o programa <code>a.out</code>, você pode observar algum navegador.
Basta substituir <code>a.out</code> por <code>google-chrome</code> ou <code>brave-browser</code>).</p>
<p>Se você executou os comandos anteriores suficientemente rápido, você deve ver
uma árvore de processos em certo instante da execução do programa <code>a.out</code>. Se
você não conseguiu ser rápido o suficiente, você pode aumentar o tempo nas
chamadas de função <code>sleep</code> ou, melhor ainda, usar o comando <code>watch</code>.</p>
<pre><code class="language-sh">watch -n 0.1 &quot;ps axjf | grep &#39;a.out&#39;&quot;
</code></pre>
<blockquote>
<p>Note os diferentes usos de aspas simples e aspas duplas nos comandos daqui
pra frente.</p>
</blockquote>
<p>As opções pra <code>ps</code> vão listar todos os processos do computador e mostrar a relação
entre alguns deles através de uma árvore. Usando o resultado do <code>ps</code>, <code>grep</code>
imprime todas as linhas com a string <code>a.out</code> presente.</p>
<p><strong>Exercício para o leitor:</strong> você pode notar que mesmo depois que o programa
<code>a.out</code> termina sua execução, o
comando <code>watch</code> continua mostrando alguns resultados de processos como <code>watch</code> e
o próprio <code>grep</code>. Pesquise na internet ou nas páginas do manual como podemos
mandar o <code>grep</code> <em>não</em> imprimir linhas com certas strings, de maneira que apareça
apenas a linhas dos processos filhos do <code>a.out</code>.</p>
<p>Para atingir o objetivo do parágrafo anterior, podemos usar a flag <code>-v</code> do <code>grep</code>:</p>
<pre><code class="language-sh">watch -n 0.1 &quot;ps axjf | grep &#39;a.out&#39; | grep -v &#39;watch&#39;&quot;
</code></pre>
<p>Se você executar assim, ainda sobra um processo que não pertence à arvore de
processos de <code>a.out</code>. Podemos removê-la com outro filtro para <code>grep</code></p>
<pre><code class="language-sh">watch -n 0.1 &quot;ps axjf | grep &#39;a.out&#39; | grep -v &#39;watch&#39; | grep -v &#39;grep&#39;&quot;
</code></pre>
<p>Mas podemos remover essa última parte de outra maneira:</p>
<pre><code class="language-sh">watch -n 0.1 &quot;ps axjf | grep &#39;a.out&#39; | grep -v -E &#39;watch|grep&#39;&quot;
</code></pre>
<p>Sem entrar em muitos detalhes, a flag <code>-E</code> habilita regex para o <code>grep</code>. No
contexto de regex, o operador <code>|</code> funciona como um operador lógico OU. Então,
pode-se ler <code>grep -v -E &#39;watch|grep&#39;</code> como &quot;não imprima as linhas que contêm
watch OU grep&quot;.</p>
<p>E finalmente, o que resta na tela é a árvore de processos do programa <code>a.out</code>.</p>
</div><a href="/blog">← Voltar</a></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"automacao-com-bash-parte-1","content":"\u003c!-- ## O que é automatizar um processo?\n\n- É a primeira coisa que um programador pensa depois de fazer a mesma coisa\n  mais de uma vez.\n\nNinguém quer ficar repetindo os mesmos comandos terminal ou na IDE.\n\n## O que é automação?\n\n- É o resultado do trabalho de alguém preguiçoso.\n\n- É diminuir a presença de uma pessoa em determinado processo.\n\n## Benefícios\n\n- O mais óbvio é a economia de tempo porque você não precisa executar uma série\n  de passos manualmente.\n\n- Reduz a carga mental do programador. Ele precisa se preocupar com menos coisas,\n  fazer menos coisas por que parte delas já estão sendo feitas por um script.\n\n- ...\n\n- _Bônus_: em alguns casos, dá uma noção melhor de como montar um pipeline de\n  Entrega Contínua, o famoso CI, conceito fundamental na área de DevOps. --\u003e\n\n\u003ch2 id=\"ideia-geral-desta-série-de-posts\"\u003eIdeia geral desta série de posts\u003c/h2\u003e\n\u003cp\u003eNesta série de posts, vou apresentar alguns processos que eu automatizei durante\nalgumas disciplinas na universidade, a maioria deles em Bash (Bourne Again Shell).\nPode ser que a automação aconteça usando outras ferrametas como o Python\ne outros em ambientes como uma IDE ou uma pipeline de CI.\u003c/p\u003e\n\u003cp\u003eA ideia é que você leia esses posts, aprenda uma ferramenta ou outra e se inspire\npara automatizar os seus próprios processos na sua vida de programação.\u003c/p\u003e\n\u003cp\u003eEu mesmo fui inspirado por uma aula da disciplina\n\u003ca href=\"https://missing.csail.mit.edu/\"\u003eMissing Semester\u003c/a\u003e do MIT.\nA aula de \u003ca href=\"https://missing.csail.mit.edu/2020/data-wrangling/\"\u003edata wrangling\u003c/a\u003e\nfoi onde eu formei a base do meu conhecimento (ainda fraca por falta de prática)\ndo programa \u003ccode\u003esed\u003c/code\u003e e de \u003ca href=\"https://en.wikipedia.org/wiki/Regular_expression\"\u003eregex\u003c/a\u003e\n(regular expressions ou expressões regulares),\nque vão ser bastante usados nesta série. Se você estuda Ciências da Computação ou\nEngeharia de Software, vale à pena você dar uma olhada nessa disciplina.\u003c/p\u003e\n\u003ch2 id=\"tópicos-deste-post\"\u003eTópicos deste post\u003c/h2\u003e\n\u003cp\u003eNeste post vamos aprender alguns conceitos e comandos:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eoperador pipe\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewatch\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eps\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egrep\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"o-que-você-precisa\"\u003eO que você precisa\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eComputador com ambiente Unix (Máquina virtual, dual boot com alguma distro Linux)\u003cul\u003e\n\u003cli\u003eSe você está em Windows, você pode usar o \u003ca href=\"https://docs.microsoft.com/en-us/windows/wsl/install\"\u003eWSL2\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eTerminal\u003c/li\u003e\n\u003cli\u003egcc (não é obrigatório)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"um-pouco-de-prática-relógio-ao-vivo-de-terminal\"\u003eUm pouco de prática: relógio ao vivo de terminal\u003c/h2\u003e\n\u003cp\u003eVamos começar com uma situação muito simples: \u003cstrong\u003emostrar as horas no terminal a cada\nintervalo de tempo, como um relógio ao vivo\u003c/strong\u003e. Em Linux, um que comando que mostra as\nhoras é o \u003ccode\u003edate\u003c/code\u003e. Se você usá-lo no terminal, você deve ver algo assim:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esex nov 26 18:40:39 -03 2021\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eComo queremos apenas as horas, podemos passar a opção \u003ccode\u003e+\u0026quot;%R:%s\u0026quot;\u003c/code\u003e. O resultado de\nexecutar \u003ccode\u003edate +\u0026quot;%R:%s\u0026quot;\u003c/code\u003e é:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e18:40:55\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMas esse comando mostra as horas apenas uma vez. Teríamos que executar o comando\n\u003ccode\u003edate\u003c/code\u003e pelo menos uma vez por segundo para termos um relógio decente. Queremos algo\nmais automático. Para isso vamos usar o comando \u003ccode\u003ewatch\u003c/code\u003e. \u003ccode\u003ewatch\u003c/code\u003e executa um comando\nperiodicamente mostrando o resultado dele em tela cheia. Esse comando é muito\nútil quando queremos observar alguma coisa que muda com o tempo sem ter que ficar\ndigitando um comando no terminal toda ver que queremos ver um resultado.\u003c/p\u003e\n\u003cp\u003eVocê pode aprender mais sobre comandos no \u003ccode\u003emanpages\u003c/code\u003e do Linux. Se você rodar\n\u003ccode\u003eman watch\u003c/code\u003e você verá algo assim no terminal:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eWATCH(1)                        User Commands                       WATCH(1)\n\nNAME\n       watch - execute a program periodically, showing output fullscreen\n\nSYNOPSIS\n       watch [options] command\n\nDESCRIPTION\n       watch  runs command repeatedly, displaying its output and errors (the\n       first screenfull).  This allows  you  to  watch  the  program  output\n       change  over  time.   By  default, command is run every 2 seconds and\n       watch will run until interrupted.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNo terminal, você pode rolar a página para baixo com as setas do teclado ou com\na barra de rolagem do mouse. Toda vez que você tiver dúvida sobre o funcionamento\nde algum comando ou suas flags e opções, \u003cdel\u003epesquise primeiro no Stackoverflow\u003c/del\u003e\nconsulte as páginas do manual para esse comando.\u003c/p\u003e\n\u003cp\u003eExecutando \u003ccode\u003ewatch date +%R\u003c/code\u003e no terminal deve resultar nas horas sendo impressas\na cada 2 segundos, com um cabeçalho com parâmetros adicionais sobre o comando. Não\né bem o que a gente quer, mas estamos quase lá. Você pode interromper a execução\nde \u003ccode\u003ewatch\u003c/code\u003e com \u003ckbd\u003eCtrl\u003c/kbd\u003e + \u003ckbd\u003eC\u003c/kbd\u003e\u003c/p\u003e\n\u003cp\u003eOlhando no manual de \u003ccode\u003ewatch\u003c/code\u003e,\npercebemos que existe uma flag \u003ccode\u003e-n\u003c/code\u003e para especificar o intervalo de tempo em\nsegundos. O intervalo padrão, como pode-se perceber é de 2 segundos. Se queremos\num relógio ao vivo, podemos diminuir o intervalo para 1 segundo ou um intervalo\nmenor que isso.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewatch -n 0.5 date +%R\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote que a flag \u003ccode\u003e-n\u003c/code\u003e é para o comando \u003ccode\u003ewatch\u003c/code\u003e e não para o comando \u003ccode\u003edate\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExercício para o leitor:\u003c/strong\u003e consultando as páginas do manual, descubra como fazer\no comando \u003ccode\u003ewatch\u003c/code\u003e não mostrar o cabeçalho com informações adicionais, ou seja,\nque mostre apenas o resultado do comando \u003ccode\u003edate\u003c/code\u003e. \u003cem\u003eDica:\u003c/em\u003e procure por título ou\ntitle.\u003c/p\u003e\n\u003ch2 id=\"um-pouco-mais-complicado-árvore-de-processos\"\u003eUm pouco mais complicado: árvore de processos\u003c/h2\u003e\n\u003cp\u003eVamos usar esses conhecimentos em um cenário um pouco mais complicado:\n\u003cstrong\u003eobservar a árvore de processos de um programa\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003ePara isso, vamos executar um programa feito em C que simplesmente cria vários\nprocessos filhos e morre depois de alguns segundos:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e// procs.c\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt; // pid_t\n#include \u0026lt;unistd.h\u0026gt; // fork, sleep\n\nint main() {\n  int i;\n  pid_t pid;\n\n  for (i = 0; i \u0026lt; 3; i++) {\n    sleep(1);\n    pid = fork();\n\n    if (pid \u0026gt; 0) {\n      sleep(2);\n      fork();\n    }\n  }\n\n  return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCompile com \u003ccode\u003egcc procs.c\u003c/code\u003e e execute com \u003ccode\u003e./a.out\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eVocê pode escolher outro programa para observar. Navegadores web (Chrome, Brave\nBrowser, Edge) são ótimos exemplos.\u003c/p\u003e\n\u003cp\u003eVamos usar novos comandos para isso:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eps\u003c/code\u003e: mostra um snapshot dos processos atuais.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egrep\u003c/code\u003e: imprime as linhas que contém determinada string.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eConsulte os manuais desses comando para saber mais (eu só traduzi essas definições\nde lá). Tome um tempo pra explorar o comando \u003ccode\u003eps\u003c/code\u003e com diferentes flags e opções.\nLeia a seção \u003ccode\u003eEXAMPLES\u003c/code\u003e do manual do \u003ccode\u003eps\u003c/code\u003e. Depois disso, tente filtrar o resultado\ndo comando \u003ccode\u003eps\u003c/code\u003e com o \u003ccode\u003egrep\u003c/code\u003e para obter os processos de determinado programa.\u003c/p\u003e\n\u003cp\u003eSe você conseguiu fazer tudo isso, fica fácil mostrar a árvore de processos de um\nprograma a sua escolha. Caso contrário, continue lendo.\u003c/p\u003e\n\u003cp\u003ePara usar esses comandos, vamos usar o\n\u003ca href=\"https://en.wikipedia.org/wiki/Pipeline_(Unix)\"\u003eoperador pipe\u003c/a\u003e em shell. O pipe\nredireciona a saída padrão de um comando (ou programa) para a entrada padrão de\noutro comando (ou programa). A partir de agora, use duas janelas de terminal: uma\npara executar os comandos de shell e a outra para executar o programa em C.\u003c/p\u003e\n\u003cp\u003eNa primeira janela, execute o programa em C com\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e./a.out\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLogo em seguida, na segunda janela de terminal, execute o seguinte:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003eps axjf | grep \u0026quot;a.out\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Ao invés de observar o programa \u003ccode\u003ea.out\u003c/code\u003e, você pode observar algum navegador.\nBasta substituir \u003ccode\u003ea.out\u003c/code\u003e por \u003ccode\u003egoogle-chrome\u003c/code\u003e ou \u003ccode\u003ebrave-browser\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eSe você executou os comandos anteriores suficientemente rápido, você deve ver\numa árvore de processos em certo instante da execução do programa \u003ccode\u003ea.out\u003c/code\u003e. Se\nvocê não conseguiu ser rápido o suficiente, você pode aumentar o tempo nas\nchamadas de função \u003ccode\u003esleep\u003c/code\u003e ou, melhor ainda, usar o comando \u003ccode\u003ewatch\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003ewatch -n 0.1 \u0026quot;ps axjf | grep \u0026#39;a.out\u0026#39;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote os diferentes usos de aspas simples e aspas duplas nos comandos daqui\npra frente.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAs opções pra \u003ccode\u003eps\u003c/code\u003e vão listar todos os processos do computador e mostrar a relação\nentre alguns deles através de uma árvore. Usando o resultado do \u003ccode\u003eps\u003c/code\u003e, \u003ccode\u003egrep\u003c/code\u003e\nimprime todas as linhas com a string \u003ccode\u003ea.out\u003c/code\u003e presente.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExercício para o leitor:\u003c/strong\u003e você pode notar que mesmo depois que o programa\n\u003ccode\u003ea.out\u003c/code\u003e termina sua execução, o\ncomando \u003ccode\u003ewatch\u003c/code\u003e continua mostrando alguns resultados de processos como \u003ccode\u003ewatch\u003c/code\u003e e\no próprio \u003ccode\u003egrep\u003c/code\u003e. Pesquise na internet ou nas páginas do manual como podemos\nmandar o \u003ccode\u003egrep\u003c/code\u003e \u003cem\u003enão\u003c/em\u003e imprimir linhas com certas strings, de maneira que apareça\napenas a linhas dos processos filhos do \u003ccode\u003ea.out\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003ePara atingir o objetivo do parágrafo anterior, podemos usar a flag \u003ccode\u003e-v\u003c/code\u003e do \u003ccode\u003egrep\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003ewatch -n 0.1 \u0026quot;ps axjf | grep \u0026#39;a.out\u0026#39; | grep -v \u0026#39;watch\u0026#39;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSe você executar assim, ainda sobra um processo que não pertence à arvore de\nprocessos de \u003ccode\u003ea.out\u003c/code\u003e. Podemos removê-la com outro filtro para \u003ccode\u003egrep\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003ewatch -n 0.1 \u0026quot;ps axjf | grep \u0026#39;a.out\u0026#39; | grep -v \u0026#39;watch\u0026#39; | grep -v \u0026#39;grep\u0026#39;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMas podemos remover essa última parte de outra maneira:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003ewatch -n 0.1 \u0026quot;ps axjf | grep \u0026#39;a.out\u0026#39; | grep -v -E \u0026#39;watch|grep\u0026#39;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSem entrar em muitos detalhes, a flag \u003ccode\u003e-E\u003c/code\u003e habilita regex para o \u003ccode\u003egrep\u003c/code\u003e. No\ncontexto de regex, o operador \u003ccode\u003e|\u003c/code\u003e funciona como um operador lógico OU. Então,\npode-se ler \u003ccode\u003egrep -v -E \u0026#39;watch|grep\u0026#39;\u003c/code\u003e como \u0026quot;não imprima as linhas que contêm\nwatch OU grep\u0026quot;.\u003c/p\u003e\n\u003cp\u003eE finalmente, o que resta na tela é a árvore de processos do programa \u003ccode\u003ea.out\u003c/code\u003e.\u003c/p\u003e\n","title":"Automação com Bash, parte 1","excerpt":"O que é automação?","date":"2021-11-20","tags":["automação","bash","série-automação"]}},"__N_SSG":true},"page":"/blog/posts/[id]","query":{"id":"automacao-com-bash-parte-1"},"buildId":"f59elqndpmj3zC08JeRq4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>